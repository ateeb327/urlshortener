{"ast":null,"code":"import getCompositeRect from './dom-utils/getCompositeRect';\nimport getLayoutRect from './dom-utils/getLayoutRect';\nimport listScrollParents from './dom-utils/listScrollParents';\nimport getOffsetParent from './dom-utils/getOffsetParent';\nimport getComputedStyle from './dom-utils/getComputedStyle';\nimport orderModifiers from './utils/orderModifiers';\nimport debounce from './utils/debounce';\nimport validateModifiers from './utils/validateModifiers';\nimport uniqueBy from './utils/uniqueBy';\nimport getBasePlacement from './utils/getBasePlacement';\nimport mergeByName from './utils/mergeByName';\nimport detectOverflow from './utils/detectOverflow';\nimport { isElement } from './dom-utils/instanceOf';\nimport { auto } from './enums';\nexport * from './types';\nexport * from './enums';\nconst INVALID_ELEMENT_ERROR = 'Popper: Invalid reference or popper argument provided. They must be either a DOM element or virtual element.';\nconst INFINITE_LOOP_ERROR = 'Popper: An infinite loop in the modifiers cycle has been detected! The cycle has been interrupted to prevent a browser crash.';\nconst DEFAULT_OPTIONS = {\n  placement: 'bottom',\n  modifiers: [],\n  strategy: 'absolute'\n};\n/**\n * @param args\n */\nfunction areValidElements(...args) {\n  return !args.some(element => !(element && typeof element.getBoundingClientRect === 'function'));\n}\n/**\n * @param generatorOptions\n */\nexport function popperGenerator(generatorOptions = {}) {\n  const {\n    defaultModifiers = [],\n    defaultOptions = DEFAULT_OPTIONS\n  } = generatorOptions;\n  return function createPopper(reference, popper, options = defaultOptions) {\n    let state = {\n      placement: 'bottom',\n      orderedModifiers: [],\n      options: Object.assign(Object.assign({}, DEFAULT_OPTIONS), defaultOptions),\n      modifiersData: {},\n      elements: {\n        reference,\n        popper\n      },\n      attributes: {},\n      styles: {}\n    };\n    let effectCleanupFns = [];\n    let isDestroyed = false;\n    const instance = {\n      state,\n      setOptions(options) {\n        cleanupModifierEffects();\n        state.options = Object.assign(Object.assign(Object.assign({}, defaultOptions), state.options), options);\n        state.scrollParents = {\n          reference: isElement(reference) ? listScrollParents(reference) : reference.contextElement ? listScrollParents(reference.contextElement) : [],\n          popper: listScrollParents(popper)\n        };\n        // Orders the modifiers based on their dependencies and `phase`\n        // properties\n        const orderedModifiers = orderModifiers(mergeByName([...defaultModifiers, ...state.options.modifiers]));\n        // Strip out disabled modifiers\n        state.orderedModifiers = orderedModifiers.filter(m => m.enabled);\n        // Validate the provided modifiers so that the consumer will get warned\n        // if one of the modifiers is invalid for any reason\n        if (false /* __DEV__*/) {\n          const modifiers = uniqueBy([...orderedModifiers, ...state.options.modifiers], ({\n            name\n          }) => name);\n          validateModifiers(modifiers);\n          if (getBasePlacement(state.options.placement) === auto) {\n            const flipModifier = state.orderedModifiers.find(({\n              name\n            }) => name === 'flip');\n            if (!flipModifier) {\n              console.error(['Popper: \"auto\" placements require the \"flip\" modifier be', 'present and enabled to work.'].join(' '));\n            }\n          }\n          const {\n            marginTop,\n            marginRight,\n            marginBottom,\n            marginLeft\n          } = getComputedStyle(popper);\n          // We no longer take into account `margins` on the popper, and it can\n          // cause bugs with positioning, so we'll warn the consumer\n          if ([marginTop, marginRight, marginBottom, marginLeft].some(margin => parseFloat(margin))) {\n            console.warn(['Popper: CSS \"margin\" styles cannot be used to apply padding', 'between the popper and its reference element or boundary.', 'To replicate margin, use the `offset` modifier, as well as', 'the `padding` option in the `preventOverflow` and `flip`', 'modifiers.'].join(' '));\n          }\n        }\n        runModifierEffects();\n        return instance.update();\n      },\n      // Sync update – it will always be executed, even if not necessary. This\n      // is useful for low frequency updates where sync behavior simplifies the\n      // logic.\n      // For high frequency updates (e.g. `resize` and `scroll` events), always\n      // prefer the async Popper#update method\n      forceUpdate() {\n        if (isDestroyed) {\n          return;\n        }\n        const {\n          reference,\n          popper\n        } = state.elements;\n        // Don't proceed if `reference` or `popper` are not valid elements\n        // anymore\n        if (!areValidElements(reference, popper)) {\n          if (false /* __DEV__*/) {\n            console.error(INVALID_ELEMENT_ERROR);\n          }\n          return;\n        }\n        // Store the reference and popper rects to be read by modifiers\n        state.rects = {\n          reference: getCompositeRect(reference, getOffsetParent(popper), state.options.strategy === 'fixed'),\n          popper: getLayoutRect(popper)\n        };\n        // Modifiers have the ability to reset the current update cycle. The\n        // most common use case for this is the `flip` modifier changing the\n        // placement, which then needs to re-run all the modifiers, because the\n        // logic was previously ran for the previous placement and is therefore\n        // stale/incorrect\n        state.reset = false;\n        state.placement = state.options.placement;\n        // On each update cycle, the `modifiersData` property for each modifier\n        // is filled with the initial data specified by the modifier. This means\n        // it doesn't persist and is fresh on each update.\n        // To ensure persistent data, use `${name}#persistent`\n        state.orderedModifiers.forEach(modifier => state.modifiersData[modifier.name] = Object.assign({}, modifier.data));\n        let __debug_loops__ = 0;\n        for (let index = 0; index < state.orderedModifiers.length; index++) {\n          if (false /* __DEV__*/) {\n            __debug_loops__ += 1;\n            if (__debug_loops__ > 100) {\n              console.error(INFINITE_LOOP_ERROR);\n              break;\n            }\n          }\n          if (state.reset === true) {\n            state.reset = false;\n            index = -1;\n            continue;\n          }\n          const {\n            fn,\n            options = {},\n            name\n          } = state.orderedModifiers[index];\n          if (typeof fn === 'function') {\n            state = fn({\n              state,\n              options,\n              name,\n              instance\n            }) || state;\n          }\n        }\n      },\n      // Async and optimistically optimized update – it will not be executed if\n      // not necessary (debounced to run at most once-per-tick)\n      update: debounce(() => new Promise(resolve => {\n        instance.forceUpdate();\n        resolve(state);\n      })),\n      destroy() {\n        cleanupModifierEffects();\n        isDestroyed = true;\n      }\n    };\n    if (!areValidElements(reference, popper)) {\n      if (false /* __DEV__*/) {\n        console.error(INVALID_ELEMENT_ERROR);\n      }\n      return instance;\n    }\n    instance.setOptions(options).then(state => {\n      if (!isDestroyed && options.onFirstUpdate) {\n        options.onFirstUpdate(state);\n      }\n    });\n    // Modifiers have the ability to execute arbitrary code before the first\n    // update cycle runs. They will be executed in the same order as the update\n    // cycle. This is useful when a modifier adds some persistent data that\n    // other modifiers need to use, but the modifier is run after the dependent\n    // one.\n    /**\n     *\n     */\n    function runModifierEffects() {\n      state.orderedModifiers.forEach(({\n        name,\n        options = {},\n        effect\n      }) => {\n        if (typeof effect === 'function') {\n          const cleanupFn = effect({\n            state,\n            name,\n            instance,\n            options\n          });\n          const noopFn = () => {};\n          effectCleanupFns.push(cleanupFn || noopFn);\n        }\n      });\n    }\n    /**\n     *\n     */\n    function cleanupModifierEffects() {\n      effectCleanupFns.forEach(fn => fn());\n      effectCleanupFns = [];\n    }\n    return instance;\n  };\n}\nexport const createPopper = popperGenerator();\n// eslint-disable-next-line import/no-unused-modules\nexport { detectOverflow };","map":{"version":3,"sources":["../../../../../../src/helpers/Popper/thirdparty/popper-core/index.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import getCompositeRect from './dom-utils/getCompositeRect';\nimport getLayoutRect from './dom-utils/getLayoutRect';\nimport listScrollParents from './dom-utils/listScrollParents';\nimport getOffsetParent from './dom-utils/getOffsetParent';\nimport getComputedStyle from './dom-utils/getComputedStyle';\nimport orderModifiers from './utils/orderModifiers';\nimport debounce from './utils/debounce';\nimport validateModifiers from './utils/validateModifiers';\nimport uniqueBy from './utils/uniqueBy';\nimport getBasePlacement from './utils/getBasePlacement';\nimport mergeByName from './utils/mergeByName';\nimport detectOverflow from './utils/detectOverflow';\nimport { isElement } from './dom-utils/instanceOf';\nimport { auto } from './enums';\nexport * from './types';\nexport * from './enums';\nconst INVALID_ELEMENT_ERROR = 'Popper: Invalid reference or popper argument provided. They must be either a DOM element or virtual element.';\nconst INFINITE_LOOP_ERROR = 'Popper: An infinite loop in the modifiers cycle has been detected! The cycle has been interrupted to prevent a browser crash.';\nconst DEFAULT_OPTIONS = {\n    placement: 'bottom',\n    modifiers: [],\n    strategy: 'absolute'\n};\n/**\n * @param args\n */\nfunction areValidElements(...args) {\n    return !args.some(element => !(element && typeof element.getBoundingClientRect === 'function'));\n}\n/**\n * @param generatorOptions\n */\nexport function popperGenerator(generatorOptions = {}) {\n    const { defaultModifiers = [], defaultOptions = DEFAULT_OPTIONS } = generatorOptions;\n    return function createPopper(reference, popper, options = defaultOptions) {\n        let state = {\n            placement: 'bottom',\n            orderedModifiers: [],\n            options: Object.assign(Object.assign({}, DEFAULT_OPTIONS), defaultOptions),\n            modifiersData: {},\n            elements: {\n                reference,\n                popper\n            },\n            attributes: {},\n            styles: {}\n        };\n        let effectCleanupFns = [];\n        let isDestroyed = false;\n        const instance = {\n            state,\n            setOptions(options) {\n                cleanupModifierEffects();\n                state.options = Object.assign(Object.assign(Object.assign({}, defaultOptions), state.options), options);\n                state.scrollParents = {\n                    reference: isElement(reference)\n                        ? listScrollParents(reference)\n                        : reference.contextElement\n                            ? listScrollParents(reference.contextElement)\n                            : [],\n                    popper: listScrollParents(popper)\n                };\n                // Orders the modifiers based on their dependencies and `phase`\n                // properties\n                const orderedModifiers = orderModifiers(mergeByName([...defaultModifiers, ...state.options.modifiers]));\n                // Strip out disabled modifiers\n                state.orderedModifiers = orderedModifiers.filter(m => m.enabled);\n                // Validate the provided modifiers so that the consumer will get warned\n                // if one of the modifiers is invalid for any reason\n                if (false /* __DEV__*/) {\n                    const modifiers = uniqueBy([...orderedModifiers, ...state.options.modifiers], ({ name }) => name);\n                    validateModifiers(modifiers);\n                    if (getBasePlacement(state.options.placement) === auto) {\n                        const flipModifier = state.orderedModifiers.find(({ name }) => name === 'flip');\n                        if (!flipModifier) {\n                            console.error(['Popper: \"auto\" placements require the \"flip\" modifier be', 'present and enabled to work.'].join(' '));\n                        }\n                    }\n                    const { marginTop, marginRight, marginBottom, marginLeft } = getComputedStyle(popper);\n                    // We no longer take into account `margins` on the popper, and it can\n                    // cause bugs with positioning, so we'll warn the consumer\n                    if ([marginTop, marginRight, marginBottom, marginLeft].some(margin => parseFloat(margin))) {\n                        console.warn([\n                            'Popper: CSS \"margin\" styles cannot be used to apply padding',\n                            'between the popper and its reference element or boundary.',\n                            'To replicate margin, use the `offset` modifier, as well as',\n                            'the `padding` option in the `preventOverflow` and `flip`',\n                            'modifiers.'\n                        ].join(' '));\n                    }\n                }\n                runModifierEffects();\n                return instance.update();\n            },\n            // Sync update – it will always be executed, even if not necessary. This\n            // is useful for low frequency updates where sync behavior simplifies the\n            // logic.\n            // For high frequency updates (e.g. `resize` and `scroll` events), always\n            // prefer the async Popper#update method\n            forceUpdate() {\n                if (isDestroyed) {\n                    return;\n                }\n                const { reference, popper } = state.elements;\n                // Don't proceed if `reference` or `popper` are not valid elements\n                // anymore\n                if (!areValidElements(reference, popper)) {\n                    if (false /* __DEV__*/) {\n                        console.error(INVALID_ELEMENT_ERROR);\n                    }\n                    return;\n                }\n                // Store the reference and popper rects to be read by modifiers\n                state.rects = {\n                    reference: getCompositeRect(reference, getOffsetParent(popper), state.options.strategy === 'fixed'),\n                    popper: getLayoutRect(popper)\n                };\n                // Modifiers have the ability to reset the current update cycle. The\n                // most common use case for this is the `flip` modifier changing the\n                // placement, which then needs to re-run all the modifiers, because the\n                // logic was previously ran for the previous placement and is therefore\n                // stale/incorrect\n                state.reset = false;\n                state.placement = state.options.placement;\n                // On each update cycle, the `modifiersData` property for each modifier\n                // is filled with the initial data specified by the modifier. This means\n                // it doesn't persist and is fresh on each update.\n                // To ensure persistent data, use `${name}#persistent`\n                state.orderedModifiers.forEach(modifier => (state.modifiersData[modifier.name] = Object.assign({}, modifier.data)));\n                let __debug_loops__ = 0;\n                for (let index = 0; index < state.orderedModifiers.length; index++) {\n                    if (false /* __DEV__*/) {\n                        __debug_loops__ += 1;\n                        if (__debug_loops__ > 100) {\n                            console.error(INFINITE_LOOP_ERROR);\n                            break;\n                        }\n                    }\n                    if (state.reset === true) {\n                        state.reset = false;\n                        index = -1;\n                        continue;\n                    }\n                    const { fn, options = {}, name } = state.orderedModifiers[index];\n                    if (typeof fn === 'function') {\n                        state = fn({ state, options, name, instance }) || state;\n                    }\n                }\n            },\n            // Async and optimistically optimized update – it will not be executed if\n            // not necessary (debounced to run at most once-per-tick)\n            update: debounce(() => new Promise(resolve => {\n                instance.forceUpdate();\n                resolve(state);\n            })),\n            destroy() {\n                cleanupModifierEffects();\n                isDestroyed = true;\n            }\n        };\n        if (!areValidElements(reference, popper)) {\n            if (false /* __DEV__*/) {\n                console.error(INVALID_ELEMENT_ERROR);\n            }\n            return instance;\n        }\n        instance.setOptions(options).then(state => {\n            if (!isDestroyed && options.onFirstUpdate) {\n                options.onFirstUpdate(state);\n            }\n        });\n        // Modifiers have the ability to execute arbitrary code before the first\n        // update cycle runs. They will be executed in the same order as the update\n        // cycle. This is useful when a modifier adds some persistent data that\n        // other modifiers need to use, but the modifier is run after the dependent\n        // one.\n        /**\n         *\n         */\n        function runModifierEffects() {\n            state.orderedModifiers.forEach(({ name, options = {}, effect }) => {\n                if (typeof effect === 'function') {\n                    const cleanupFn = effect({ state, name, instance, options });\n                    const noopFn = () => { };\n                    effectCleanupFns.push(cleanupFn || noopFn);\n                }\n            });\n        }\n        /**\n         *\n         */\n        function cleanupModifierEffects() {\n            effectCleanupFns.forEach(fn => fn());\n            effectCleanupFns = [];\n        }\n        return instance;\n    };\n}\nexport const createPopper = popperGenerator();\n// eslint-disable-next-line import/no-unused-modules\nexport { detectOverflow };\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"module"}