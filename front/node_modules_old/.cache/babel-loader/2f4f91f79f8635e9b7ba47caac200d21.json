{"ast":null,"code":"import { viewport } from '../enums';\nimport getViewportRect from './getViewportRect';\nimport getDocumentRect from './getDocumentRect';\nimport listScrollParents from './listScrollParents';\nimport getOffsetParent from './getOffsetParent';\nimport getDocumentElement from './getDocumentElement';\nimport getComputedStyle from './getComputedStyle';\nimport { isElement, isHTMLElement } from './instanceOf';\nimport getBoundingClientRect from './getBoundingClientRect';\nimport getParentNode from './getParentNode';\nimport contains from './contains';\nimport getNodeName from './getNodeName';\nimport rectToClientRect from '../utils/rectToClientRect';\n/**\n * @param element\n */\nfunction getInnerBoundingClientRect(element) {\n  const rect = getBoundingClientRect(element);\n  rect.top = rect.top + element.clientTop;\n  rect.left = rect.left + element.clientLeft;\n  rect.bottom = rect.top + element.clientHeight;\n  rect.right = rect.left + element.clientWidth;\n  rect.width = element.clientWidth;\n  rect.height = element.clientHeight;\n  rect.x = rect.left;\n  rect.y = rect.top;\n  return rect;\n}\n/**\n * @param element\n * @param clippingParent\n */\nfunction getClientRectFromMixedType(element, clippingParent) {\n  return clippingParent === viewport ? rectToClientRect(getViewportRect(element)) : isHTMLElement(clippingParent) ? getInnerBoundingClientRect(clippingParent) : rectToClientRect(getDocumentRect(getDocumentElement(element)));\n}\n// A \"clipping parent\" is an overflowable container with the characteristic of\n// clipping (or hiding) overflowing elements with a position different from\n// `initial`\n/**\n * @param element\n */\nfunction getClippingParents(element) {\n  const clippingParents = listScrollParents(getParentNode(element));\n  const canEscapeClipping = ['absolute', 'fixed'].indexOf(getComputedStyle(element).position) >= 0;\n  const clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;\n  if (!isElement(clipperElement)) {\n    return [];\n  }\n  // $FlowFixMe: https://github.com/facebook/flow/issues/1414\n  return clippingParents.filter(clippingParent => isElement(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== 'body');\n}\n// Gets the maximum area that the element is visible in due to any number of\n// clipping parents\n/**\n * @param element\n * @param boundary\n * @param rootBoundary\n */\nexport default function getClippingRect(element, boundary, rootBoundary) {\n  const mainClippingParents = boundary === 'clippingParents' ? getClippingParents(element) : [].concat(boundary);\n  const clippingParents = [...mainClippingParents, rootBoundary];\n  const firstClippingParent = clippingParents[0];\n  const clippingRect = clippingParents.reduce((accRect, clippingParent) => {\n    const rect = getClientRectFromMixedType(element, clippingParent);\n    accRect.top = Math.max(rect.top, accRect.top);\n    accRect.right = Math.min(rect.right, accRect.right);\n    accRect.bottom = Math.min(rect.bottom, accRect.bottom);\n    accRect.left = Math.max(rect.left, accRect.left);\n    return accRect;\n  }, getClientRectFromMixedType(element, firstClippingParent));\n  clippingRect.width = clippingRect.right - clippingRect.left;\n  clippingRect.height = clippingRect.bottom - clippingRect.top;\n  clippingRect.x = clippingRect.left;\n  clippingRect.y = clippingRect.top;\n  return clippingRect;\n}","map":{"version":3,"sources":["../../../../../../../src/helpers/Popper/thirdparty/popper-core/dom-utils/getClippingRect.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { viewport } from '../enums';\nimport getViewportRect from './getViewportRect';\nimport getDocumentRect from './getDocumentRect';\nimport listScrollParents from './listScrollParents';\nimport getOffsetParent from './getOffsetParent';\nimport getDocumentElement from './getDocumentElement';\nimport getComputedStyle from './getComputedStyle';\nimport { isElement, isHTMLElement } from './instanceOf';\nimport getBoundingClientRect from './getBoundingClientRect';\nimport getParentNode from './getParentNode';\nimport contains from './contains';\nimport getNodeName from './getNodeName';\nimport rectToClientRect from '../utils/rectToClientRect';\n/**\n * @param element\n */\nfunction getInnerBoundingClientRect(element) {\n    const rect = getBoundingClientRect(element);\n    rect.top = rect.top + element.clientTop;\n    rect.left = rect.left + element.clientLeft;\n    rect.bottom = rect.top + element.clientHeight;\n    rect.right = rect.left + element.clientWidth;\n    rect.width = element.clientWidth;\n    rect.height = element.clientHeight;\n    rect.x = rect.left;\n    rect.y = rect.top;\n    return rect;\n}\n/**\n * @param element\n * @param clippingParent\n */\nfunction getClientRectFromMixedType(element, clippingParent) {\n    return clippingParent === viewport\n        ? rectToClientRect(getViewportRect(element))\n        : isHTMLElement(clippingParent)\n            ? getInnerBoundingClientRect(clippingParent)\n            : rectToClientRect(getDocumentRect(getDocumentElement(element)));\n}\n// A \"clipping parent\" is an overflowable container with the characteristic of\n// clipping (or hiding) overflowing elements with a position different from\n// `initial`\n/**\n * @param element\n */\nfunction getClippingParents(element) {\n    const clippingParents = listScrollParents(getParentNode(element));\n    const canEscapeClipping = ['absolute', 'fixed'].indexOf(getComputedStyle(element).position) >= 0;\n    const clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;\n    if (!isElement(clipperElement)) {\n        return [];\n    }\n    // $FlowFixMe: https://github.com/facebook/flow/issues/1414\n    return clippingParents.filter(clippingParent => isElement(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== 'body');\n}\n// Gets the maximum area that the element is visible in due to any number of\n// clipping parents\n/**\n * @param element\n * @param boundary\n * @param rootBoundary\n */\nexport default function getClippingRect(element, boundary, rootBoundary) {\n    const mainClippingParents = boundary === 'clippingParents' ? getClippingParents(element) : [].concat(boundary);\n    const clippingParents = [...mainClippingParents, rootBoundary];\n    const firstClippingParent = clippingParents[0];\n    const clippingRect = clippingParents.reduce((accRect, clippingParent) => {\n        const rect = getClientRectFromMixedType(element, clippingParent);\n        accRect.top = Math.max(rect.top, accRect.top);\n        accRect.right = Math.min(rect.right, accRect.right);\n        accRect.bottom = Math.min(rect.bottom, accRect.bottom);\n        accRect.left = Math.max(rect.left, accRect.left);\n        return accRect;\n    }, getClientRectFromMixedType(element, firstClippingParent));\n    clippingRect.width = clippingRect.right - clippingRect.left;\n    clippingRect.height = clippingRect.bottom - clippingRect.top;\n    clippingRect.x = clippingRect.left;\n    clippingRect.y = clippingRect.top;\n    return clippingRect;\n}\n//# sourceMappingURL=getClippingRect.js.map"]},"metadata":{},"sourceType":"module"}