{"ast":null,"code":"import getOppositePlacement from '../utils/getOppositePlacement';\nimport getBasePlacement from '../utils/getBasePlacement';\nimport getOppositeVariationPlacement from '../utils/getOppositeVariationPlacement';\nimport detectOverflow from '../utils/detectOverflow';\nimport computeAutoPlacement from '../utils/computeAutoPlacement';\nimport { bottom, top, start, right, left, auto } from '../enums';\nimport getVariation from '../utils/getVariation';\n/**\n * @param placement\n */\nfunction getExpandedFallbackPlacements(placement) {\n  if (getBasePlacement(placement) === auto) {\n    return [];\n  }\n  const oppositePlacement = getOppositePlacement(placement);\n  return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];\n}\n/**\n *\n */\nfunction flip({\n  state,\n  options,\n  name\n}) {\n  if (state.modifiersData[name]._skip) {\n    return;\n  }\n  const {\n    mainAxis: checkMainAxis = true,\n    altAxis: checkAltAxis = true,\n    fallbackPlacements: specifiedFallbackPlacements,\n    padding,\n    boundary,\n    rootBoundary,\n    altBoundary,\n    flipVariations = true,\n    allowedAutoPlacements\n  } = options;\n  const preferredPlacement = state.options.placement;\n  const basePlacement = getBasePlacement(preferredPlacement);\n  const isBasePlacement = basePlacement === preferredPlacement;\n  const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));\n  const placements = [preferredPlacement, ...fallbackPlacements].reduce((acc, placement) => acc.concat(getBasePlacement(placement) === auto ? computeAutoPlacement(state, {\n    placement,\n    boundary,\n    rootBoundary,\n    padding,\n    flipVariations,\n    allowedAutoPlacements\n  }) : placement), []);\n  const referenceRect = state.rects.reference;\n  const popperRect = state.rects.popper;\n  const checksMap = new Map();\n  let makeFallbackChecks = true;\n  let firstFittingPlacement = placements[0];\n  for (let i = 0; i < placements.length; i++) {\n    const placement = placements[i];\n    const basePlacement = getBasePlacement(placement);\n    const isStartVariation = getVariation(placement) === start;\n    const isVertical = [top, bottom].indexOf(basePlacement) >= 0;\n    const len = isVertical ? 'width' : 'height';\n    const overflow = detectOverflow(state, {\n      placement,\n      boundary,\n      rootBoundary,\n      altBoundary,\n      padding\n    });\n    let mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;\n    if (referenceRect[len] > popperRect[len]) {\n      mainVariationSide = getOppositePlacement(mainVariationSide);\n    }\n    const altVariationSide = getOppositePlacement(mainVariationSide);\n    const checks = [];\n    if (checkMainAxis) {\n      checks.push(overflow[basePlacement] <= 0);\n    }\n    if (checkAltAxis) {\n      checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);\n    }\n    if (checks.every(check => check)) {\n      firstFittingPlacement = placement;\n      makeFallbackChecks = false;\n      break;\n    }\n    checksMap.set(placement, checks);\n  }\n  if (makeFallbackChecks) {\n    // `2` may be desired in some cases – research later\n    const numberOfChecks = flipVariations ? 3 : 1;\n    for (let i = numberOfChecks; i > 0; i--) {\n      const fittingPlacement = placements.find(placement => {\n        const checks = checksMap.get(placement);\n        if (checks) {\n          return checks.slice(0, i).every(check => check);\n        }\n      });\n      if (fittingPlacement) {\n        firstFittingPlacement = fittingPlacement;\n        break;\n      }\n    }\n  }\n  if (state.placement !== firstFittingPlacement) {\n    state.modifiersData[name]._skip = true;\n    state.placement = firstFittingPlacement;\n    state.reset = true;\n  }\n}\nexport default {\n  name: 'flip',\n  enabled: true,\n  phase: 'main',\n  fn: flip,\n  requiresIfExists: ['offset'],\n  data: {\n    _skip: false\n  }\n};","map":{"version":3,"sources":["../../../../../../../src/helpers/Popper/thirdparty/popper-core/modifiers/flip.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import getOppositePlacement from '../utils/getOppositePlacement';\nimport getBasePlacement from '../utils/getBasePlacement';\nimport getOppositeVariationPlacement from '../utils/getOppositeVariationPlacement';\nimport detectOverflow from '../utils/detectOverflow';\nimport computeAutoPlacement from '../utils/computeAutoPlacement';\nimport { bottom, top, start, right, left, auto } from '../enums';\nimport getVariation from '../utils/getVariation';\n/**\n * @param placement\n */\nfunction getExpandedFallbackPlacements(placement) {\n    if (getBasePlacement(placement) === auto) {\n        return [];\n    }\n    const oppositePlacement = getOppositePlacement(placement);\n    return [\n        getOppositeVariationPlacement(placement),\n        oppositePlacement,\n        getOppositeVariationPlacement(oppositePlacement)\n    ];\n}\n/**\n *\n */\nfunction flip({ state, options, name }) {\n    if (state.modifiersData[name]._skip) {\n        return;\n    }\n    const { mainAxis: checkMainAxis = true, altAxis: checkAltAxis = true, fallbackPlacements: specifiedFallbackPlacements, padding, boundary, rootBoundary, altBoundary, flipVariations = true, allowedAutoPlacements } = options;\n    const preferredPlacement = state.options.placement;\n    const basePlacement = getBasePlacement(preferredPlacement);\n    const isBasePlacement = basePlacement === preferredPlacement;\n    const fallbackPlacements = specifiedFallbackPlacements ||\n        (isBasePlacement || !flipVariations\n            ? [getOppositePlacement(preferredPlacement)]\n            : getExpandedFallbackPlacements(preferredPlacement));\n    const placements = [preferredPlacement, ...fallbackPlacements].reduce((acc, placement) => acc.concat(getBasePlacement(placement) === auto\n        ? computeAutoPlacement(state, {\n            placement,\n            boundary,\n            rootBoundary,\n            padding,\n            flipVariations,\n            allowedAutoPlacements\n        })\n        : placement), []);\n    const referenceRect = state.rects.reference;\n    const popperRect = state.rects.popper;\n    const checksMap = new Map();\n    let makeFallbackChecks = true;\n    let firstFittingPlacement = placements[0];\n    for (let i = 0; i < placements.length; i++) {\n        const placement = placements[i];\n        const basePlacement = getBasePlacement(placement);\n        const isStartVariation = getVariation(placement) === start;\n        const isVertical = [top, bottom].indexOf(basePlacement) >= 0;\n        const len = isVertical ? 'width' : 'height';\n        const overflow = detectOverflow(state, {\n            placement,\n            boundary,\n            rootBoundary,\n            altBoundary,\n            padding\n        });\n        let mainVariationSide = isVertical ? (isStartVariation ? right : left) : isStartVariation ? bottom : top;\n        if (referenceRect[len] > popperRect[len]) {\n            mainVariationSide = getOppositePlacement(mainVariationSide);\n        }\n        const altVariationSide = getOppositePlacement(mainVariationSide);\n        const checks = [];\n        if (checkMainAxis) {\n            checks.push(overflow[basePlacement] <= 0);\n        }\n        if (checkAltAxis) {\n            checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);\n        }\n        if (checks.every(check => check)) {\n            firstFittingPlacement = placement;\n            makeFallbackChecks = false;\n            break;\n        }\n        checksMap.set(placement, checks);\n    }\n    if (makeFallbackChecks) {\n        // `2` may be desired in some cases – research later\n        const numberOfChecks = flipVariations ? 3 : 1;\n        for (let i = numberOfChecks; i > 0; i--) {\n            const fittingPlacement = placements.find(placement => {\n                const checks = checksMap.get(placement);\n                if (checks) {\n                    return checks.slice(0, i).every(check => check);\n                }\n            });\n            if (fittingPlacement) {\n                firstFittingPlacement = fittingPlacement;\n                break;\n            }\n        }\n    }\n    if (state.placement !== firstFittingPlacement) {\n        state.modifiersData[name]._skip = true;\n        state.placement = firstFittingPlacement;\n        state.reset = true;\n    }\n}\nexport default {\n    name: 'flip',\n    enabled: true,\n    phase: 'main',\n    fn: flip,\n    requiresIfExists: ['offset'],\n    data: { _skip: false }\n};\n//# sourceMappingURL=flip.js.map"]},"metadata":{},"sourceType":"module"}