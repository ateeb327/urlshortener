{"ast":null,"code":"import { __rest } from \"tslib\";\nimport * as React from 'react';\nimport styles from '@patternfly/react-styles/css/components/DualListSelector/dual-list-selector';\nimport { css } from '@patternfly/react-styles';\nimport AngleDoubleLeftIcon from '@patternfly/react-icons/dist/esm/icons/angle-double-left-icon';\nimport AngleLeftIcon from '@patternfly/react-icons/dist/esm/icons/angle-left-icon';\nimport AngleDoubleRightIcon from '@patternfly/react-icons/dist/esm/icons/angle-double-right-icon';\nimport AngleRightIcon from '@patternfly/react-icons/dist/esm/icons/angle-right-icon';\nimport { DualListSelectorPane } from './DualListSelectorPane';\nimport { GenerateId } from '../../helpers';\nimport { flattenTree, flattenTreeWithFolders, filterFolders, filterTreeItems, filterTreeItemsWithoutFolders, filterRestTreeItems } from './treeUtils';\nimport { DualListSelectorControlsWrapper } from './DualListSelectorControlsWrapper';\nimport { DualListSelectorControl } from './DualListSelectorControl';\nimport { DualListSelectorContext } from './DualListSelectorContext';\nexport class DualListSelector extends React.Component {\n  constructor(props) {\n    super(props);\n    this.addAllButtonRef = React.createRef();\n    this.addSelectedButtonRef = React.createRef();\n    this.removeSelectedButtonRef = React.createRef();\n    this.removeAllButtonRef = React.createRef();\n    /** In dev environment, prevents circular structure during JSON stringification when\n     * options passed in to the dual list selector include HTML elements.\n     */\n    this.replacer = (key, value) => {\n      if (key[0] === '_') {\n        return undefined;\n      }\n      return value;\n    };\n    this.onFilterUpdate = (newFilteredOptions, paneType, isSearchReset) => {\n      const {\n        isTree\n      } = this.props;\n      if (paneType === 'available') {\n        if (isSearchReset) {\n          this.setState({\n            availableFilteredOptions: null,\n            availableTreeFilteredOptions: null\n          });\n          return;\n        }\n        if (isTree) {\n          this.setState({\n            availableTreeFilteredOptions: flattenTreeWithFolders(newFilteredOptions)\n          });\n        } else {\n          this.setState({\n            availableFilteredOptions: newFilteredOptions\n          });\n        }\n      } else if (paneType === 'chosen') {\n        if (isSearchReset) {\n          this.setState({\n            chosenFilteredOptions: null,\n            chosenTreeFilteredOptions: null\n          });\n          return;\n        }\n        if (isTree) {\n          this.setState({\n            chosenTreeFilteredOptions: flattenTreeWithFolders(newFilteredOptions)\n          });\n        } else {\n          this.setState({\n            chosenFilteredOptions: newFilteredOptions\n          });\n        }\n      }\n    };\n    this.addAllVisible = () => {\n      this.setState(prevState => {\n        const itemsToRemove = [];\n        const newAvailable = [];\n        const movedOptions = prevState.availableFilteredOptions || prevState.availableOptions;\n        prevState.availableOptions.forEach(value => {\n          if (movedOptions.indexOf(value) !== -1) {\n            itemsToRemove.push(value);\n          } else {\n            newAvailable.push(value);\n          }\n        });\n        const newChosen = [...prevState.chosenOptions, ...itemsToRemove];\n        this.props.addAll && this.props.addAll(newAvailable, newChosen);\n        this.props.onListChange && this.props.onListChange(newAvailable, newChosen);\n        return {\n          chosenOptions: newChosen,\n          chosenFilteredOptions: newChosen,\n          availableOptions: newAvailable,\n          availableFilteredOptions: newAvailable,\n          chosenOptionsSelected: [],\n          availableOptionsSelected: []\n        };\n      });\n    };\n    this.addAllTreeVisible = () => {\n      this.setState(prevState => {\n        const movedOptions = prevState.availableTreeFilteredOptions || flattenTreeWithFolders(prevState.availableOptions);\n        const newAvailable = prevState.availableOptions.map(opt => Object.assign({}, opt)).filter(item => filterRestTreeItems(item, movedOptions));\n        const currChosen = flattenTree(prevState.chosenOptions);\n        const nextChosenOptions = currChosen.concat(movedOptions);\n        const newChosen = this.createMergedCopy().map(opt => Object.assign({}, opt)).filter(item => filterTreeItemsWithoutFolders(item, nextChosenOptions));\n        this.props.addAll && this.props.addAll(newAvailable, newChosen);\n        this.props.onListChange && this.props.onListChange(newAvailable, newChosen);\n        return {\n          chosenOptions: newChosen,\n          chosenFilteredOptions: newChosen,\n          availableOptions: newAvailable,\n          availableFilteredOptions: newAvailable,\n          availableTreeOptionsChecked: [],\n          chosenTreeOptionsChecked: []\n        };\n      });\n    };\n    this.addSelected = () => {\n      this.setState(prevState => {\n        const itemsToRemove = [];\n        const newAvailable = [];\n        prevState.availableOptions.forEach((value, index) => {\n          if (prevState.availableOptionsSelected.indexOf(index) !== -1) {\n            itemsToRemove.push(value);\n          } else {\n            newAvailable.push(value);\n          }\n        });\n        const newChosen = [...prevState.chosenOptions, ...itemsToRemove];\n        this.props.addSelected && this.props.addSelected(newAvailable, newChosen);\n        this.props.onListChange && this.props.onListChange(newAvailable, newChosen);\n        return {\n          chosenOptionsSelected: [],\n          availableOptionsSelected: [],\n          chosenOptions: newChosen,\n          chosenFilteredOptions: newChosen,\n          availableOptions: newAvailable,\n          availableFilteredOptions: newAvailable\n        };\n      });\n    };\n    this.addTreeSelected = () => {\n      this.setState(prevState => {\n        // Remove selected available nodes from current available nodes\n        const newAvailable = prevState.availableOptions.map(opt => Object.assign({}, opt)).filter(item => filterRestTreeItems(item, prevState.availableTreeOptionsChecked));\n        // Get next chosen options from current + new nodes and remap from base\n        const currChosen = flattenTree(prevState.chosenOptions);\n        const nextChosenOptions = currChosen.concat(prevState.availableTreeOptionsChecked);\n        const newChosen = this.createMergedCopy().map(opt => Object.assign({}, opt)).filter(item => filterTreeItemsWithoutFolders(item, nextChosenOptions));\n        this.props.addSelected && this.props.addSelected(newAvailable, newChosen);\n        this.props.onListChange && this.props.onListChange(newAvailable, newChosen);\n        return {\n          availableTreeOptionsChecked: [],\n          chosenTreeOptionsChecked: [],\n          availableOptions: newAvailable,\n          chosenOptions: newChosen\n        };\n      });\n    };\n    this.removeAllVisible = () => {\n      this.setState(prevState => {\n        const itemsToRemove = [];\n        const newChosen = [];\n        const movedOptions = prevState.chosenFilteredOptions || prevState.chosenOptions;\n        prevState.chosenOptions.forEach(value => {\n          if (movedOptions.indexOf(value) !== -1) {\n            itemsToRemove.push(value);\n          } else {\n            newChosen.push(value);\n          }\n        });\n        const newAvailable = [...prevState.availableOptions, ...itemsToRemove];\n        this.props.removeAll && this.props.removeAll(newAvailable, newChosen);\n        this.props.onListChange && this.props.onListChange(newAvailable, newChosen);\n        return {\n          chosenOptions: newChosen,\n          chosenFilteredOptions: newChosen,\n          availableOptions: newAvailable,\n          availableFilteredOptions: newAvailable,\n          chosenOptionsSelected: [],\n          availableOptionsSelected: []\n        };\n      });\n    };\n    this.removeAllTreeVisible = () => {\n      this.setState(prevState => {\n        const movedOptions = prevState.chosenTreeFilteredOptions || flattenTreeWithFolders(prevState.chosenOptions);\n        const newChosen = prevState.chosenOptions.map(opt => Object.assign({}, opt)).filter(item => filterRestTreeItems(item, movedOptions));\n        const currAvailable = flattenTree(prevState.availableOptions);\n        const nextAvailableOptions = currAvailable.concat(movedOptions);\n        const newAvailable = this.createMergedCopy().map(opt => Object.assign({}, opt)).filter(item => filterTreeItemsWithoutFolders(item, nextAvailableOptions));\n        this.props.removeAll && this.props.removeAll(newAvailable, newChosen);\n        this.props.onListChange && this.props.onListChange(newAvailable, newChosen);\n        return {\n          chosenOptions: newChosen,\n          availableOptions: newAvailable,\n          availableTreeOptionsChecked: [],\n          chosenTreeOptionsChecked: []\n        };\n      });\n    };\n    this.removeSelected = () => {\n      this.setState(prevState => {\n        const itemsToRemove = [];\n        const newChosen = [];\n        prevState.chosenOptions.forEach((value, index) => {\n          if (prevState.chosenOptionsSelected.indexOf(index) !== -1) {\n            itemsToRemove.push(value);\n          } else {\n            newChosen.push(value);\n          }\n        });\n        const newAvailable = [...prevState.availableOptions, ...itemsToRemove];\n        this.props.removeSelected && this.props.removeSelected(newAvailable, newChosen);\n        this.props.onListChange && this.props.onListChange(newAvailable, newChosen);\n        return {\n          chosenOptionsSelected: [],\n          availableOptionsSelected: [],\n          chosenOptions: newChosen,\n          chosenFilteredOptions: newChosen,\n          availableOptions: newAvailable,\n          availableFilteredOptions: newAvailable\n        };\n      });\n    };\n    this.removeTreeSelected = () => {\n      this.setState(prevState => {\n        // Remove selected chosen nodes from current chosen nodes\n        const newChosen = prevState.chosenOptions.map(opt => Object.assign({}, opt)).filter(item => filterRestTreeItems(item, prevState.chosenTreeOptionsChecked));\n        // Get next chosen options from current and remap from base\n        const currAvailable = flattenTree(prevState.availableOptions);\n        const nextAvailableOptions = currAvailable.concat(prevState.chosenTreeOptionsChecked);\n        const newAvailable = this.createMergedCopy().map(opt => Object.assign({}, opt)).filter(item => filterTreeItemsWithoutFolders(item, nextAvailableOptions));\n        this.props.removeSelected && this.props.removeSelected(newAvailable, newChosen);\n        this.props.onListChange && this.props.onListChange(newAvailable, newChosen);\n        return {\n          availableTreeOptionsChecked: [],\n          chosenTreeOptionsChecked: [],\n          availableOptions: newAvailable,\n          chosenOptions: newChosen\n        };\n      });\n    };\n    this.onOptionSelect = (e, index, isChosen, /* eslint-disable @typescript-eslint/no-unused-vars */\n    id, itemData, parentData\n    /* eslint-enable @typescript-eslint/no-unused-vars */) => {\n      this.setState(prevState => {\n        const originalArray = isChosen ? prevState.chosenOptionsSelected : prevState.availableOptionsSelected;\n        let updatedArray = null;\n        if (originalArray.indexOf(index) !== -1) {\n          updatedArray = originalArray.filter(value => value !== index);\n        } else {\n          updatedArray = [...originalArray, index];\n        }\n        return {\n          chosenOptionsSelected: isChosen ? updatedArray : prevState.chosenOptionsSelected,\n          availableOptionsSelected: isChosen ? prevState.availableOptionsSelected : updatedArray\n        };\n      });\n      this.props.onOptionSelect && this.props.onOptionSelect(e, index, isChosen, id, itemData, parentData);\n    };\n    this.isChecked = (treeItem, isChosen) => isChosen ? this.state.chosenTreeOptionsChecked.includes(treeItem.id) : this.state.availableTreeOptionsChecked.includes(treeItem.id);\n    this.areAllDescendantsChecked = (treeItem, isChosen) => treeItem.children ? treeItem.children.every(child => this.areAllDescendantsChecked(child, isChosen)) : this.isChecked(treeItem, isChosen);\n    this.areSomeDescendantsChecked = (treeItem, isChosen) => treeItem.children ? treeItem.children.some(child => this.areSomeDescendantsChecked(child, isChosen)) : this.isChecked(treeItem, isChosen);\n    this.mapChecked = (item, isChosen) => {\n      const hasCheck = this.areAllDescendantsChecked(item, isChosen);\n      item.isChecked = false;\n      if (hasCheck) {\n        item.isChecked = true;\n      } else {\n        const hasPartialCheck = this.areSomeDescendantsChecked(item, isChosen);\n        if (hasPartialCheck) {\n          item.isChecked = null;\n        }\n      }\n      if (item.children) {\n        return Object.assign(Object.assign({}, item), {\n          children: item.children.map(child => this.mapChecked(child, isChosen))\n        });\n      }\n      return item;\n    };\n    this.onTreeOptionCheck = (evt, isChecked, itemData, isChosen) => {\n      const {\n        availableOptions,\n        availableTreeFilteredOptions,\n        chosenOptions,\n        chosenTreeFilteredOptions\n      } = this.state;\n      let panelOptions;\n      if (isChosen) {\n        if (chosenTreeFilteredOptions) {\n          panelOptions = chosenOptions.map(opt => Object.assign({}, opt)).filter(item => filterTreeItemsWithoutFolders(item, chosenTreeFilteredOptions));\n        } else {\n          panelOptions = chosenOptions;\n        }\n      } else {\n        if (availableTreeFilteredOptions) {\n          panelOptions = availableOptions.map(opt => Object.assign({}, opt)).filter(item => filterTreeItemsWithoutFolders(item, availableTreeFilteredOptions));\n        } else {\n          panelOptions = availableOptions;\n        }\n      }\n      const checkedOptionTree = panelOptions.map(opt => Object.assign({}, opt)).filter(item => filterTreeItems(item, [itemData.id]));\n      const flatTree = flattenTreeWithFolders(checkedOptionTree);\n      const prevChecked = isChosen ? this.state.chosenTreeOptionsChecked : this.state.availableTreeOptionsChecked;\n      let updatedChecked = [];\n      if (isChecked) {\n        updatedChecked = prevChecked.concat(flatTree.filter(id => !prevChecked.includes(id)));\n      } else {\n        updatedChecked = prevChecked.filter(id => !flatTree.includes(id));\n      }\n      this.setState(prevState => ({\n        availableTreeOptionsChecked: isChosen ? prevState.availableTreeOptionsChecked : updatedChecked,\n        chosenTreeOptionsChecked: isChosen ? updatedChecked : prevState.chosenTreeOptionsChecked\n      }), () => {\n        this.props.onOptionCheck && this.props.onOptionCheck(evt, isChecked, itemData.id, updatedChecked);\n      });\n    };\n    this.state = {\n      availableOptions: [...this.props.availableOptions],\n      availableOptionsSelected: [],\n      availableFilteredOptions: null,\n      availableTreeFilteredOptions: null,\n      chosenOptions: [...this.props.chosenOptions],\n      chosenOptionsSelected: [],\n      chosenFilteredOptions: null,\n      chosenTreeFilteredOptions: null,\n      availableTreeOptionsChecked: [],\n      chosenTreeOptionsChecked: []\n    };\n  }\n  // If the DualListSelector uses trees, concat the two initial arrays and merge duplicate folder IDs\n  createMergedCopy() {\n    const copyOfAvailable = JSON.parse(JSON.stringify(this.props.availableOptions));\n    const copyOfChosen = JSON.parse(JSON.stringify(this.props.chosenOptions));\n    return this.props.isTree ? Object.values(copyOfAvailable.concat(copyOfChosen).reduce((mapObj, item) => {\n      const key = item.id;\n      if (mapObj[key]) {\n        // If map already has an item ID, add the dupe ID's children to the existing map\n        mapObj[key].children.push(...item.children);\n      } else {\n        // Else clone the item data\n        mapObj[key] = Object.assign({}, item);\n      }\n      return mapObj;\n    }, {})) : null;\n  }\n  componentDidUpdate() {\n    if (JSON.stringify(this.props.availableOptions, this.replacer) !== JSON.stringify(this.state.availableOptions, this.replacer) || JSON.stringify(this.props.chosenOptions, this.replacer) !== JSON.stringify(this.state.chosenOptions, this.replacer)) {\n      this.setState({\n        availableOptions: [...this.props.availableOptions],\n        chosenOptions: [...this.props.chosenOptions]\n      });\n    }\n  }\n  render() {\n    const _a = this.props,\n      {\n        availableOptionsTitle,\n        availableOptionsActions,\n        availableOptionsSearchAriaLabel,\n        className,\n        children,\n        chosenOptionsTitle,\n        chosenOptionsActions,\n        chosenOptionsSearchAriaLabel,\n        filterOption,\n        isSearchable,\n        chosenOptionsStatus,\n        availableOptionsStatus,\n        controlsAriaLabel,\n        addAllAriaLabel,\n        addSelectedAriaLabel,\n        removeSelectedAriaLabel,\n        removeAllAriaLabel,\n        /* eslint-disable @typescript-eslint/no-unused-vars */\n        availableOptions: consumerPassedAvailableOptions,\n        chosenOptions: consumerPassedChosenOptions,\n        removeSelected,\n        addAll,\n        removeAll,\n        addSelected,\n        onListChange,\n        onAvailableOptionsSearchInputChanged,\n        onChosenOptionsSearchInputChanged,\n        onOptionSelect,\n        onOptionCheck,\n        id,\n        isTree,\n        isDisabled,\n        addAllTooltip,\n        addAllTooltipProps,\n        addSelectedTooltip,\n        addSelectedTooltipProps,\n        removeAllTooltip,\n        removeAllTooltipProps,\n        removeSelectedTooltip,\n        removeSelectedTooltipProps\n      } = _a,\n      props = __rest(_a, [\"availableOptionsTitle\", \"availableOptionsActions\", \"availableOptionsSearchAriaLabel\", \"className\", \"children\", \"chosenOptionsTitle\", \"chosenOptionsActions\", \"chosenOptionsSearchAriaLabel\", \"filterOption\", \"isSearchable\", \"chosenOptionsStatus\", \"availableOptionsStatus\", \"controlsAriaLabel\", \"addAllAriaLabel\", \"addSelectedAriaLabel\", \"removeSelectedAriaLabel\", \"removeAllAriaLabel\", \"availableOptions\", \"chosenOptions\", \"removeSelected\", \"addAll\", \"removeAll\", \"addSelected\", \"onListChange\", \"onAvailableOptionsSearchInputChanged\", \"onChosenOptionsSearchInputChanged\", \"onOptionSelect\", \"onOptionCheck\", \"id\", \"isTree\", \"isDisabled\", \"addAllTooltip\", \"addAllTooltipProps\", \"addSelectedTooltip\", \"addSelectedTooltipProps\", \"removeAllTooltip\", \"removeAllTooltipProps\", \"removeSelectedTooltip\", \"removeSelectedTooltipProps\"]);\n    const {\n      availableOptions,\n      chosenOptions,\n      chosenOptionsSelected,\n      availableOptionsSelected,\n      chosenTreeOptionsChecked,\n      availableTreeOptionsChecked\n    } = this.state;\n    const availableOptionsStatusToDisplay = availableOptionsStatus || (isTree ? `${filterFolders(availableOptions, availableTreeOptionsChecked).length} of ${flattenTree(availableOptions).length} items selected` : `${availableOptionsSelected.length} of ${availableOptions.length} items selected`);\n    const chosenOptionsStatusToDisplay = chosenOptionsStatus || (isTree ? `${filterFolders(chosenOptions, chosenTreeOptionsChecked).length} of ${flattenTree(chosenOptions).length} items selected` : `${chosenOptionsSelected.length} of ${chosenOptions.length} items selected`);\n    const available = isTree ? availableOptions.map(item => this.mapChecked(item, false)) : availableOptions;\n    const chosen = isTree ? chosenOptions.map(item => this.mapChecked(item, true)) : chosenOptions;\n    return React.createElement(DualListSelectorContext.Provider, {\n      value: {\n        isTree\n      }\n    }, React.createElement(GenerateId, null, randomId => React.createElement(\"div\", Object.assign({\n      className: css(styles.dualListSelector, className),\n      id: id || randomId\n    }, props), children === '' ? React.createElement(React.Fragment, null, React.createElement(DualListSelectorPane, {\n      isSearchable: isSearchable,\n      onFilterUpdate: this.onFilterUpdate,\n      searchInputAriaLabel: availableOptionsSearchAriaLabel,\n      filterOption: filterOption,\n      onSearchInputChanged: onAvailableOptionsSearchInputChanged,\n      status: availableOptionsStatusToDisplay,\n      title: availableOptionsTitle,\n      options: available,\n      selectedOptions: isTree ? availableTreeOptionsChecked : availableOptionsSelected,\n      onOptionSelect: this.onOptionSelect,\n      onOptionCheck: (e, isChecked, itemData) => this.onTreeOptionCheck(e, isChecked, itemData, false),\n      actions: availableOptionsActions,\n      id: `${id || randomId}-available-pane`,\n      isDisabled: isDisabled\n    }), React.createElement(DualListSelectorControlsWrapper, {\n      \"aria-label\": controlsAriaLabel\n    }, React.createElement(DualListSelectorControl, {\n      isDisabled: (isTree ? availableTreeOptionsChecked.length === 0 : availableOptionsSelected.length === 0) || isDisabled,\n      onClick: isTree ? this.addTreeSelected : this.addSelected,\n      ref: this.addSelectedButtonRef,\n      \"aria-label\": addSelectedAriaLabel,\n      tooltipContent: addSelectedTooltip,\n      tooltipProps: addSelectedTooltipProps\n    }, React.createElement(AngleRightIcon, null)), React.createElement(DualListSelectorControl, {\n      isDisabled: availableOptions.length === 0 || isDisabled,\n      onClick: isTree ? this.addAllTreeVisible : this.addAllVisible,\n      ref: this.addAllButtonRef,\n      \"aria-label\": addAllAriaLabel,\n      tooltipContent: addAllTooltip,\n      tooltipProps: addAllTooltipProps\n    }, React.createElement(AngleDoubleRightIcon, null)), React.createElement(DualListSelectorControl, {\n      isDisabled: chosenOptions.length === 0 || isDisabled,\n      onClick: isTree ? this.removeAllTreeVisible : this.removeAllVisible,\n      \"aria-label\": removeAllAriaLabel,\n      ref: this.removeAllButtonRef,\n      tooltipContent: removeAllTooltip,\n      tooltipProps: removeAllTooltipProps\n    }, React.createElement(AngleDoubleLeftIcon, null)), React.createElement(DualListSelectorControl, {\n      onClick: isTree ? this.removeTreeSelected : this.removeSelected,\n      isDisabled: (isTree ? chosenTreeOptionsChecked.length === 0 : chosenOptionsSelected.length === 0) || isDisabled,\n      ref: this.removeSelectedButtonRef,\n      \"aria-label\": removeSelectedAriaLabel,\n      tooltipContent: removeSelectedTooltip,\n      tooltipProps: removeSelectedTooltipProps\n    }, React.createElement(AngleLeftIcon, null))), React.createElement(DualListSelectorPane, {\n      isChosen: true,\n      isSearchable: isSearchable,\n      onFilterUpdate: this.onFilterUpdate,\n      searchInputAriaLabel: chosenOptionsSearchAriaLabel,\n      filterOption: filterOption,\n      onSearchInputChanged: onChosenOptionsSearchInputChanged,\n      title: chosenOptionsTitle,\n      status: chosenOptionsStatusToDisplay,\n      options: chosen,\n      selectedOptions: isTree ? chosenTreeOptionsChecked : chosenOptionsSelected,\n      onOptionSelect: this.onOptionSelect,\n      onOptionCheck: (e, isChecked, itemData) => this.onTreeOptionCheck(e, isChecked, itemData, true),\n      actions: chosenOptionsActions,\n      id: `${id || randomId}-chosen-pane`,\n      isDisabled: isDisabled\n    })) : children)));\n  }\n}\nDualListSelector.displayName = 'DualListSelector';\nDualListSelector.defaultProps = {\n  children: '',\n  availableOptions: [],\n  availableOptionsTitle: 'Available options',\n  availableOptionsSearchAriaLabel: 'Available search input',\n  chosenOptions: [],\n  chosenOptionsTitle: 'Chosen options',\n  chosenOptionsSearchAriaLabel: 'Chosen search input',\n  controlsAriaLabel: 'Selector controls',\n  addAllAriaLabel: 'Add all',\n  addSelectedAriaLabel: 'Add selected',\n  removeSelectedAriaLabel: 'Remove selected',\n  removeAllAriaLabel: 'Remove all',\n  isTree: false,\n  isDisabled: false\n};","map":{"version":3,"sources":["../../../../src/components/DualListSelector/DualListSelector.tsx"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { __rest } from \"tslib\";\nimport * as React from 'react';\nimport styles from '@patternfly/react-styles/css/components/DualListSelector/dual-list-selector';\nimport { css } from '@patternfly/react-styles';\nimport AngleDoubleLeftIcon from '@patternfly/react-icons/dist/esm/icons/angle-double-left-icon';\nimport AngleLeftIcon from '@patternfly/react-icons/dist/esm/icons/angle-left-icon';\nimport AngleDoubleRightIcon from '@patternfly/react-icons/dist/esm/icons/angle-double-right-icon';\nimport AngleRightIcon from '@patternfly/react-icons/dist/esm/icons/angle-right-icon';\nimport { DualListSelectorPane } from './DualListSelectorPane';\nimport { GenerateId } from '../../helpers';\nimport { flattenTree, flattenTreeWithFolders, filterFolders, filterTreeItems, filterTreeItemsWithoutFolders, filterRestTreeItems } from './treeUtils';\nimport { DualListSelectorControlsWrapper } from './DualListSelectorControlsWrapper';\nimport { DualListSelectorControl } from './DualListSelectorControl';\nimport { DualListSelectorContext } from './DualListSelectorContext';\nexport class DualListSelector extends React.Component {\n    constructor(props) {\n        super(props);\n        this.addAllButtonRef = React.createRef();\n        this.addSelectedButtonRef = React.createRef();\n        this.removeSelectedButtonRef = React.createRef();\n        this.removeAllButtonRef = React.createRef();\n        /** In dev environment, prevents circular structure during JSON stringification when\n         * options passed in to the dual list selector include HTML elements.\n         */\n        this.replacer = (key, value) => {\n            if (key[0] === '_') {\n                return undefined;\n            }\n            return value;\n        };\n        this.onFilterUpdate = (newFilteredOptions, paneType, isSearchReset) => {\n            const { isTree } = this.props;\n            if (paneType === 'available') {\n                if (isSearchReset) {\n                    this.setState({\n                        availableFilteredOptions: null,\n                        availableTreeFilteredOptions: null\n                    });\n                    return;\n                }\n                if (isTree) {\n                    this.setState({\n                        availableTreeFilteredOptions: flattenTreeWithFolders(newFilteredOptions)\n                    });\n                }\n                else {\n                    this.setState({\n                        availableFilteredOptions: newFilteredOptions\n                    });\n                }\n            }\n            else if (paneType === 'chosen') {\n                if (isSearchReset) {\n                    this.setState({\n                        chosenFilteredOptions: null,\n                        chosenTreeFilteredOptions: null\n                    });\n                    return;\n                }\n                if (isTree) {\n                    this.setState({\n                        chosenTreeFilteredOptions: flattenTreeWithFolders(newFilteredOptions)\n                    });\n                }\n                else {\n                    this.setState({\n                        chosenFilteredOptions: newFilteredOptions\n                    });\n                }\n            }\n        };\n        this.addAllVisible = () => {\n            this.setState(prevState => {\n                const itemsToRemove = [];\n                const newAvailable = [];\n                const movedOptions = prevState.availableFilteredOptions || prevState.availableOptions;\n                prevState.availableOptions.forEach(value => {\n                    if (movedOptions.indexOf(value) !== -1) {\n                        itemsToRemove.push(value);\n                    }\n                    else {\n                        newAvailable.push(value);\n                    }\n                });\n                const newChosen = [...prevState.chosenOptions, ...itemsToRemove];\n                this.props.addAll && this.props.addAll(newAvailable, newChosen);\n                this.props.onListChange && this.props.onListChange(newAvailable, newChosen);\n                return {\n                    chosenOptions: newChosen,\n                    chosenFilteredOptions: newChosen,\n                    availableOptions: newAvailable,\n                    availableFilteredOptions: newAvailable,\n                    chosenOptionsSelected: [],\n                    availableOptionsSelected: []\n                };\n            });\n        };\n        this.addAllTreeVisible = () => {\n            this.setState(prevState => {\n                const movedOptions = prevState.availableTreeFilteredOptions ||\n                    flattenTreeWithFolders(prevState.availableOptions);\n                const newAvailable = prevState.availableOptions\n                    .map(opt => Object.assign({}, opt))\n                    .filter(item => filterRestTreeItems(item, movedOptions));\n                const currChosen = flattenTree(prevState.chosenOptions);\n                const nextChosenOptions = currChosen.concat(movedOptions);\n                const newChosen = this.createMergedCopy()\n                    .map(opt => Object.assign({}, opt))\n                    .filter(item => filterTreeItemsWithoutFolders(item, nextChosenOptions));\n                this.props.addAll && this.props.addAll(newAvailable, newChosen);\n                this.props.onListChange && this.props.onListChange(newAvailable, newChosen);\n                return {\n                    chosenOptions: newChosen,\n                    chosenFilteredOptions: newChosen,\n                    availableOptions: newAvailable,\n                    availableFilteredOptions: newAvailable,\n                    availableTreeOptionsChecked: [],\n                    chosenTreeOptionsChecked: []\n                };\n            });\n        };\n        this.addSelected = () => {\n            this.setState(prevState => {\n                const itemsToRemove = [];\n                const newAvailable = [];\n                prevState.availableOptions.forEach((value, index) => {\n                    if (prevState.availableOptionsSelected.indexOf(index) !== -1) {\n                        itemsToRemove.push(value);\n                    }\n                    else {\n                        newAvailable.push(value);\n                    }\n                });\n                const newChosen = [...prevState.chosenOptions, ...itemsToRemove];\n                this.props.addSelected && this.props.addSelected(newAvailable, newChosen);\n                this.props.onListChange && this.props.onListChange(newAvailable, newChosen);\n                return {\n                    chosenOptionsSelected: [],\n                    availableOptionsSelected: [],\n                    chosenOptions: newChosen,\n                    chosenFilteredOptions: newChosen,\n                    availableOptions: newAvailable,\n                    availableFilteredOptions: newAvailable\n                };\n            });\n        };\n        this.addTreeSelected = () => {\n            this.setState(prevState => {\n                // Remove selected available nodes from current available nodes\n                const newAvailable = prevState.availableOptions\n                    .map(opt => Object.assign({}, opt))\n                    .filter(item => filterRestTreeItems(item, prevState.availableTreeOptionsChecked));\n                // Get next chosen options from current + new nodes and remap from base\n                const currChosen = flattenTree(prevState.chosenOptions);\n                const nextChosenOptions = currChosen.concat(prevState.availableTreeOptionsChecked);\n                const newChosen = this.createMergedCopy()\n                    .map(opt => Object.assign({}, opt))\n                    .filter(item => filterTreeItemsWithoutFolders(item, nextChosenOptions));\n                this.props.addSelected && this.props.addSelected(newAvailable, newChosen);\n                this.props.onListChange && this.props.onListChange(newAvailable, newChosen);\n                return {\n                    availableTreeOptionsChecked: [],\n                    chosenTreeOptionsChecked: [],\n                    availableOptions: newAvailable,\n                    chosenOptions: newChosen\n                };\n            });\n        };\n        this.removeAllVisible = () => {\n            this.setState(prevState => {\n                const itemsToRemove = [];\n                const newChosen = [];\n                const movedOptions = prevState.chosenFilteredOptions || prevState.chosenOptions;\n                prevState.chosenOptions.forEach(value => {\n                    if (movedOptions.indexOf(value) !== -1) {\n                        itemsToRemove.push(value);\n                    }\n                    else {\n                        newChosen.push(value);\n                    }\n                });\n                const newAvailable = [...prevState.availableOptions, ...itemsToRemove];\n                this.props.removeAll && this.props.removeAll(newAvailable, newChosen);\n                this.props.onListChange && this.props.onListChange(newAvailable, newChosen);\n                return {\n                    chosenOptions: newChosen,\n                    chosenFilteredOptions: newChosen,\n                    availableOptions: newAvailable,\n                    availableFilteredOptions: newAvailable,\n                    chosenOptionsSelected: [],\n                    availableOptionsSelected: []\n                };\n            });\n        };\n        this.removeAllTreeVisible = () => {\n            this.setState(prevState => {\n                const movedOptions = prevState.chosenTreeFilteredOptions ||\n                    flattenTreeWithFolders(prevState.chosenOptions);\n                const newChosen = prevState.chosenOptions\n                    .map(opt => Object.assign({}, opt))\n                    .filter(item => filterRestTreeItems(item, movedOptions));\n                const currAvailable = flattenTree(prevState.availableOptions);\n                const nextAvailableOptions = currAvailable.concat(movedOptions);\n                const newAvailable = this.createMergedCopy()\n                    .map(opt => Object.assign({}, opt))\n                    .filter(item => filterTreeItemsWithoutFolders(item, nextAvailableOptions));\n                this.props.removeAll && this.props.removeAll(newAvailable, newChosen);\n                this.props.onListChange && this.props.onListChange(newAvailable, newChosen);\n                return {\n                    chosenOptions: newChosen,\n                    availableOptions: newAvailable,\n                    availableTreeOptionsChecked: [],\n                    chosenTreeOptionsChecked: []\n                };\n            });\n        };\n        this.removeSelected = () => {\n            this.setState(prevState => {\n                const itemsToRemove = [];\n                const newChosen = [];\n                prevState.chosenOptions.forEach((value, index) => {\n                    if (prevState.chosenOptionsSelected.indexOf(index) !== -1) {\n                        itemsToRemove.push(value);\n                    }\n                    else {\n                        newChosen.push(value);\n                    }\n                });\n                const newAvailable = [...prevState.availableOptions, ...itemsToRemove];\n                this.props.removeSelected && this.props.removeSelected(newAvailable, newChosen);\n                this.props.onListChange && this.props.onListChange(newAvailable, newChosen);\n                return {\n                    chosenOptionsSelected: [],\n                    availableOptionsSelected: [],\n                    chosenOptions: newChosen,\n                    chosenFilteredOptions: newChosen,\n                    availableOptions: newAvailable,\n                    availableFilteredOptions: newAvailable\n                };\n            });\n        };\n        this.removeTreeSelected = () => {\n            this.setState(prevState => {\n                // Remove selected chosen nodes from current chosen nodes\n                const newChosen = prevState.chosenOptions\n                    .map(opt => Object.assign({}, opt))\n                    .filter(item => filterRestTreeItems(item, prevState.chosenTreeOptionsChecked));\n                // Get next chosen options from current and remap from base\n                const currAvailable = flattenTree(prevState.availableOptions);\n                const nextAvailableOptions = currAvailable.concat(prevState.chosenTreeOptionsChecked);\n                const newAvailable = this.createMergedCopy()\n                    .map(opt => Object.assign({}, opt))\n                    .filter(item => filterTreeItemsWithoutFolders(item, nextAvailableOptions));\n                this.props.removeSelected && this.props.removeSelected(newAvailable, newChosen);\n                this.props.onListChange && this.props.onListChange(newAvailable, newChosen);\n                return {\n                    availableTreeOptionsChecked: [],\n                    chosenTreeOptionsChecked: [],\n                    availableOptions: newAvailable,\n                    chosenOptions: newChosen\n                };\n            });\n        };\n        this.onOptionSelect = (e, index, isChosen, \n        /* eslint-disable @typescript-eslint/no-unused-vars */\n        id, itemData, parentData\n        /* eslint-enable @typescript-eslint/no-unused-vars */\n        ) => {\n            this.setState(prevState => {\n                const originalArray = isChosen ? prevState.chosenOptionsSelected : prevState.availableOptionsSelected;\n                let updatedArray = null;\n                if (originalArray.indexOf(index) !== -1) {\n                    updatedArray = originalArray.filter(value => value !== index);\n                }\n                else {\n                    updatedArray = [...originalArray, index];\n                }\n                return {\n                    chosenOptionsSelected: isChosen ? updatedArray : prevState.chosenOptionsSelected,\n                    availableOptionsSelected: isChosen ? prevState.availableOptionsSelected : updatedArray\n                };\n            });\n            this.props.onOptionSelect && this.props.onOptionSelect(e, index, isChosen, id, itemData, parentData);\n        };\n        this.isChecked = (treeItem, isChosen) => isChosen\n            ? this.state.chosenTreeOptionsChecked.includes(treeItem.id)\n            : this.state.availableTreeOptionsChecked.includes(treeItem.id);\n        this.areAllDescendantsChecked = (treeItem, isChosen) => treeItem.children\n            ? treeItem.children.every(child => this.areAllDescendantsChecked(child, isChosen))\n            : this.isChecked(treeItem, isChosen);\n        this.areSomeDescendantsChecked = (treeItem, isChosen) => treeItem.children\n            ? treeItem.children.some(child => this.areSomeDescendantsChecked(child, isChosen))\n            : this.isChecked(treeItem, isChosen);\n        this.mapChecked = (item, isChosen) => {\n            const hasCheck = this.areAllDescendantsChecked(item, isChosen);\n            item.isChecked = false;\n            if (hasCheck) {\n                item.isChecked = true;\n            }\n            else {\n                const hasPartialCheck = this.areSomeDescendantsChecked(item, isChosen);\n                if (hasPartialCheck) {\n                    item.isChecked = null;\n                }\n            }\n            if (item.children) {\n                return Object.assign(Object.assign({}, item), { children: item.children.map(child => this.mapChecked(child, isChosen)) });\n            }\n            return item;\n        };\n        this.onTreeOptionCheck = (evt, isChecked, itemData, isChosen) => {\n            const { availableOptions, availableTreeFilteredOptions, chosenOptions, chosenTreeFilteredOptions } = this.state;\n            let panelOptions;\n            if (isChosen) {\n                if (chosenTreeFilteredOptions) {\n                    panelOptions = chosenOptions\n                        .map(opt => Object.assign({}, opt))\n                        .filter(item => filterTreeItemsWithoutFolders(item, chosenTreeFilteredOptions));\n                }\n                else {\n                    panelOptions = chosenOptions;\n                }\n            }\n            else {\n                if (availableTreeFilteredOptions) {\n                    panelOptions = availableOptions\n                        .map(opt => Object.assign({}, opt))\n                        .filter(item => filterTreeItemsWithoutFolders(item, availableTreeFilteredOptions));\n                }\n                else {\n                    panelOptions = availableOptions;\n                }\n            }\n            const checkedOptionTree = panelOptions\n                .map(opt => Object.assign({}, opt))\n                .filter(item => filterTreeItems(item, [itemData.id]));\n            const flatTree = flattenTreeWithFolders(checkedOptionTree);\n            const prevChecked = isChosen ? this.state.chosenTreeOptionsChecked : this.state.availableTreeOptionsChecked;\n            let updatedChecked = [];\n            if (isChecked) {\n                updatedChecked = prevChecked.concat(flatTree.filter(id => !prevChecked.includes(id)));\n            }\n            else {\n                updatedChecked = prevChecked.filter(id => !flatTree.includes(id));\n            }\n            this.setState(prevState => ({\n                availableTreeOptionsChecked: isChosen ? prevState.availableTreeOptionsChecked : updatedChecked,\n                chosenTreeOptionsChecked: isChosen ? updatedChecked : prevState.chosenTreeOptionsChecked\n            }), () => {\n                this.props.onOptionCheck && this.props.onOptionCheck(evt, isChecked, itemData.id, updatedChecked);\n            });\n        };\n        this.state = {\n            availableOptions: [...this.props.availableOptions],\n            availableOptionsSelected: [],\n            availableFilteredOptions: null,\n            availableTreeFilteredOptions: null,\n            chosenOptions: [...this.props.chosenOptions],\n            chosenOptionsSelected: [],\n            chosenFilteredOptions: null,\n            chosenTreeFilteredOptions: null,\n            availableTreeOptionsChecked: [],\n            chosenTreeOptionsChecked: []\n        };\n    }\n    // If the DualListSelector uses trees, concat the two initial arrays and merge duplicate folder IDs\n    createMergedCopy() {\n        const copyOfAvailable = JSON.parse(JSON.stringify(this.props.availableOptions));\n        const copyOfChosen = JSON.parse(JSON.stringify(this.props.chosenOptions));\n        return this.props.isTree\n            ? Object.values(copyOfAvailable\n                .concat(copyOfChosen)\n                .reduce((mapObj, item) => {\n                const key = item.id;\n                if (mapObj[key]) {\n                    // If map already has an item ID, add the dupe ID's children to the existing map\n                    mapObj[key].children.push(...item.children);\n                }\n                else {\n                    // Else clone the item data\n                    mapObj[key] = Object.assign({}, item);\n                }\n                return mapObj;\n            }, {}))\n            : null;\n    }\n    componentDidUpdate() {\n        if (JSON.stringify(this.props.availableOptions, this.replacer) !==\n            JSON.stringify(this.state.availableOptions, this.replacer) ||\n            JSON.stringify(this.props.chosenOptions, this.replacer) !==\n                JSON.stringify(this.state.chosenOptions, this.replacer)) {\n            this.setState({\n                availableOptions: [...this.props.availableOptions],\n                chosenOptions: [...this.props.chosenOptions]\n            });\n        }\n    }\n    render() {\n        const _a = this.props, { availableOptionsTitle, availableOptionsActions, availableOptionsSearchAriaLabel, className, children, chosenOptionsTitle, chosenOptionsActions, chosenOptionsSearchAriaLabel, filterOption, isSearchable, chosenOptionsStatus, availableOptionsStatus, controlsAriaLabel, addAllAriaLabel, addSelectedAriaLabel, removeSelectedAriaLabel, removeAllAriaLabel, \n        /* eslint-disable @typescript-eslint/no-unused-vars */\n        availableOptions: consumerPassedAvailableOptions, chosenOptions: consumerPassedChosenOptions, removeSelected, addAll, removeAll, addSelected, onListChange, onAvailableOptionsSearchInputChanged, onChosenOptionsSearchInputChanged, onOptionSelect, onOptionCheck, id, isTree, isDisabled, addAllTooltip, addAllTooltipProps, addSelectedTooltip, addSelectedTooltipProps, removeAllTooltip, removeAllTooltipProps, removeSelectedTooltip, removeSelectedTooltipProps } = _a, props = __rest(_a, [\"availableOptionsTitle\", \"availableOptionsActions\", \"availableOptionsSearchAriaLabel\", \"className\", \"children\", \"chosenOptionsTitle\", \"chosenOptionsActions\", \"chosenOptionsSearchAriaLabel\", \"filterOption\", \"isSearchable\", \"chosenOptionsStatus\", \"availableOptionsStatus\", \"controlsAriaLabel\", \"addAllAriaLabel\", \"addSelectedAriaLabel\", \"removeSelectedAriaLabel\", \"removeAllAriaLabel\", \"availableOptions\", \"chosenOptions\", \"removeSelected\", \"addAll\", \"removeAll\", \"addSelected\", \"onListChange\", \"onAvailableOptionsSearchInputChanged\", \"onChosenOptionsSearchInputChanged\", \"onOptionSelect\", \"onOptionCheck\", \"id\", \"isTree\", \"isDisabled\", \"addAllTooltip\", \"addAllTooltipProps\", \"addSelectedTooltip\", \"addSelectedTooltipProps\", \"removeAllTooltip\", \"removeAllTooltipProps\", \"removeSelectedTooltip\", \"removeSelectedTooltipProps\"]);\n        const { availableOptions, chosenOptions, chosenOptionsSelected, availableOptionsSelected, chosenTreeOptionsChecked, availableTreeOptionsChecked } = this.state;\n        const availableOptionsStatusToDisplay = availableOptionsStatus ||\n            (isTree\n                ? `${filterFolders(availableOptions, availableTreeOptionsChecked)\n                    .length} of ${flattenTree(availableOptions).length} items selected`\n                : `${availableOptionsSelected.length} of ${availableOptions.length} items selected`);\n        const chosenOptionsStatusToDisplay = chosenOptionsStatus ||\n            (isTree\n                ? `${filterFolders(chosenOptions, chosenTreeOptionsChecked).length} of ${flattenTree(chosenOptions).length} items selected`\n                : `${chosenOptionsSelected.length} of ${chosenOptions.length} items selected`);\n        const available = (isTree\n            ? availableOptions.map(item => this.mapChecked(item, false))\n            : availableOptions);\n        const chosen = (isTree\n            ? chosenOptions.map(item => this.mapChecked(item, true))\n            : chosenOptions);\n        return (React.createElement(DualListSelectorContext.Provider, { value: { isTree } },\n            React.createElement(GenerateId, null, randomId => (React.createElement(\"div\", Object.assign({ className: css(styles.dualListSelector, className), id: id || randomId }, props), children === '' ? (React.createElement(React.Fragment, null,\n                React.createElement(DualListSelectorPane, { isSearchable: isSearchable, onFilterUpdate: this.onFilterUpdate, searchInputAriaLabel: availableOptionsSearchAriaLabel, filterOption: filterOption, onSearchInputChanged: onAvailableOptionsSearchInputChanged, status: availableOptionsStatusToDisplay, title: availableOptionsTitle, options: available, selectedOptions: isTree ? availableTreeOptionsChecked : availableOptionsSelected, onOptionSelect: this.onOptionSelect, onOptionCheck: (e, isChecked, itemData) => this.onTreeOptionCheck(e, isChecked, itemData, false), actions: availableOptionsActions, id: `${id || randomId}-available-pane`, isDisabled: isDisabled }),\n                React.createElement(DualListSelectorControlsWrapper, { \"aria-label\": controlsAriaLabel },\n                    React.createElement(DualListSelectorControl, { isDisabled: (isTree ? availableTreeOptionsChecked.length === 0 : availableOptionsSelected.length === 0) ||\n                            isDisabled, onClick: isTree ? this.addTreeSelected : this.addSelected, ref: this.addSelectedButtonRef, \"aria-label\": addSelectedAriaLabel, tooltipContent: addSelectedTooltip, tooltipProps: addSelectedTooltipProps },\n                        React.createElement(AngleRightIcon, null)),\n                    React.createElement(DualListSelectorControl, { isDisabled: availableOptions.length === 0 || isDisabled, onClick: isTree ? this.addAllTreeVisible : this.addAllVisible, ref: this.addAllButtonRef, \"aria-label\": addAllAriaLabel, tooltipContent: addAllTooltip, tooltipProps: addAllTooltipProps },\n                        React.createElement(AngleDoubleRightIcon, null)),\n                    React.createElement(DualListSelectorControl, { isDisabled: chosenOptions.length === 0 || isDisabled, onClick: isTree ? this.removeAllTreeVisible : this.removeAllVisible, \"aria-label\": removeAllAriaLabel, ref: this.removeAllButtonRef, tooltipContent: removeAllTooltip, tooltipProps: removeAllTooltipProps },\n                        React.createElement(AngleDoubleLeftIcon, null)),\n                    React.createElement(DualListSelectorControl, { onClick: isTree ? this.removeTreeSelected : this.removeSelected, isDisabled: (isTree ? chosenTreeOptionsChecked.length === 0 : chosenOptionsSelected.length === 0) ||\n                            isDisabled, ref: this.removeSelectedButtonRef, \"aria-label\": removeSelectedAriaLabel, tooltipContent: removeSelectedTooltip, tooltipProps: removeSelectedTooltipProps },\n                        React.createElement(AngleLeftIcon, null))),\n                React.createElement(DualListSelectorPane, { isChosen: true, isSearchable: isSearchable, onFilterUpdate: this.onFilterUpdate, searchInputAriaLabel: chosenOptionsSearchAriaLabel, filterOption: filterOption, onSearchInputChanged: onChosenOptionsSearchInputChanged, title: chosenOptionsTitle, status: chosenOptionsStatusToDisplay, options: chosen, selectedOptions: isTree ? chosenTreeOptionsChecked : chosenOptionsSelected, onOptionSelect: this.onOptionSelect, onOptionCheck: (e, isChecked, itemData) => this.onTreeOptionCheck(e, isChecked, itemData, true), actions: chosenOptionsActions, id: `${id || randomId}-chosen-pane`, isDisabled: isDisabled }))) : (children))))));\n    }\n}\nDualListSelector.displayName = 'DualListSelector';\nDualListSelector.defaultProps = {\n    children: '',\n    availableOptions: [],\n    availableOptionsTitle: 'Available options',\n    availableOptionsSearchAriaLabel: 'Available search input',\n    chosenOptions: [],\n    chosenOptionsTitle: 'Chosen options',\n    chosenOptionsSearchAriaLabel: 'Chosen search input',\n    controlsAriaLabel: 'Selector controls',\n    addAllAriaLabel: 'Add all',\n    addSelectedAriaLabel: 'Add selected',\n    removeSelectedAriaLabel: 'Remove selected',\n    removeAllAriaLabel: 'Remove all',\n    isTree: false,\n    isDisabled: false\n};\n//# sourceMappingURL=DualListSelector.js.map"]},"metadata":{},"sourceType":"module"}