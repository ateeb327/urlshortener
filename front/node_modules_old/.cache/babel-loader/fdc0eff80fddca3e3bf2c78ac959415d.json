{"ast":null,"code":"import { __rest } from \"tslib\";\nimport * as React from 'react';\nimport { css } from '@patternfly/react-styles';\nimport styles from '@patternfly/react-styles/css/components/DragDrop/drag-drop';\nimport { DroppableContext } from './DroppableContext';\nimport { DragDropContext } from './DragDrop';\n// Browsers really like being different from each other.\nfunction getDefaultBackground() {\n  const div = document.createElement('div');\n  document.head.appendChild(div);\n  const bg = window.getComputedStyle(div).backgroundColor;\n  document.head.removeChild(div);\n  return bg;\n}\nfunction getInheritedBackgroundColor(el) {\n  const defaultStyle = getDefaultBackground();\n  const backgroundColor = window.getComputedStyle(el).backgroundColor;\n  if (backgroundColor !== defaultStyle) {\n    return backgroundColor;\n  } else if (!el.parentElement) {\n    return defaultStyle;\n  }\n  return getInheritedBackgroundColor(el.parentElement);\n}\nfunction removeBlankDiv(node) {\n  if (node.getAttribute('blankDiv') === 'true') {\n    // eslint-disable-next-line @typescript-eslint/prefer-for-of\n    for (let i = 0; i < node.children.length; i++) {\n      const child = node.children[i];\n      if (child.getAttribute('blankDiv') === 'true') {\n        node.removeChild(child);\n        node.setAttribute('blankDiv', 'false');\n        break;\n      }\n    }\n  }\n}\n// Reset per-element state\nfunction resetDroppableItem(droppableItem) {\n  removeBlankDiv(droppableItem.node);\n  droppableItem.node.classList.remove(styles.modifiers.dragging);\n  droppableItem.node.classList.remove(styles.modifiers.dragOutside);\n  droppableItem.draggableNodes.forEach((n, i) => {\n    n.style.transform = '';\n    n.style.transition = '';\n    droppableItem.draggableNodesRects[i] = n.getBoundingClientRect();\n  });\n}\nfunction overlaps(ev, rect) {\n  return ev.clientX > rect.x && ev.clientX < rect.x + rect.width && ev.clientY > rect.y && ev.clientY < rect.y + rect.height;\n}\nexport const Draggable = _a => {\n  var {\n      className,\n      children,\n      style: styleProp = {},\n      hasNoWrapper = false\n    } = _a,\n    props = __rest(_a, [\"className\", \"children\", \"style\", \"hasNoWrapper\"]);\n  /* eslint-disable prefer-const */\n  let [style, setStyle] = React.useState(styleProp);\n  /* eslint-enable prefer-const */\n  const [isDragging, setIsDragging] = React.useState(false);\n  const [isValidDrag, setIsValidDrag] = React.useState(true);\n  const {\n    zone,\n    droppableId\n  } = React.useContext(DroppableContext);\n  const {\n    onDrag,\n    onDragMove,\n    onDrop\n  } = React.useContext(DragDropContext);\n  // Some state is better just to leave as vars passed around between various callbacks\n  // You can only drag around one item at a time anyways...\n  let startX = 0;\n  let startY = 0;\n  let index = null; // Index of this draggable\n  let hoveringDroppable;\n  let hoveringIndex = null;\n  let mouseMoveListener;\n  let mouseUpListener;\n  // Makes it so dragging the _bottom_ of the item over the halfway of another moves it\n  let startYOffset = 0;\n  // After item returning to where it started animation completes\n  const onTransitionEnd = _ev => {\n    if (isDragging) {\n      setIsDragging(false);\n      setStyle(styleProp);\n    }\n  };\n  function getSourceAndDest() {\n    const hoveringDroppableId = hoveringDroppable ? hoveringDroppable.getAttribute('data-pf-droppableid') : null;\n    const source = {\n      droppableId,\n      index\n    };\n    const dest = hoveringDroppableId !== null && hoveringIndex !== null ? {\n      droppableId: hoveringDroppableId,\n      index: hoveringIndex\n    } : undefined;\n    return {\n      source,\n      dest,\n      hoveringDroppableId\n    };\n  }\n  const onMouseUpWhileDragging = droppableItems => {\n    droppableItems.forEach(resetDroppableItem);\n    document.removeEventListener('mousemove', mouseMoveListener);\n    document.removeEventListener('mouseup', mouseUpListener);\n    document.removeEventListener('contextmenu', mouseUpListener);\n    const {\n      source,\n      dest,\n      hoveringDroppableId\n    } = getSourceAndDest();\n    const consumerReordered = onDrop(source, dest);\n    if (consumerReordered && droppableId === hoveringDroppableId) {\n      setIsDragging(false);\n      setStyle(styleProp);\n    } else if (!consumerReordered) {\n      // Animate item returning to where it started\n      setStyle(Object.assign(Object.assign({}, style), {\n        transition: 'transform 0.5s cubic-bezier(0.2, 1, 0.1, 1) 0s',\n        transform: '',\n        background: styleProp.background,\n        boxShadow: styleProp.boxShadow\n      }));\n    }\n  };\n  // This is where the magic happens\n  const onMouseMoveWhileDragging = (ev, droppableItems, blankDivRect) => {\n    // Compute each time what droppable node we are hovering over\n    hoveringDroppable = null;\n    droppableItems.forEach(droppableItem => {\n      const {\n        node,\n        rect,\n        isDraggingHost,\n        draggableNodes,\n        draggableNodesRects\n      } = droppableItem;\n      if (overlaps(ev, rect)) {\n        // Add valid dropzone style\n        node.classList.remove(styles.modifiers.dragOutside);\n        hoveringDroppable = node;\n        // Check if we need to add a blank div row\n        if (node.getAttribute('blankDiv') !== 'true' && !isDraggingHost) {\n          const blankDiv = document.createElement('div');\n          blankDiv.setAttribute('blankDiv', 'true'); // Makes removing easier\n          let blankDivPos = -1;\n          for (let i = 0; i < draggableNodes.length; i++) {\n            const childRect = draggableNodesRects[i];\n            const isLast = i === draggableNodes.length - 1;\n            const startOverlaps = childRect.y >= startY - startYOffset;\n            if ((startOverlaps || isLast) && blankDivPos === -1) {\n              if (isLast && !startOverlaps) {\n                draggableNodes[i].after(blankDiv);\n              } else {\n                draggableNodes[i].before(blankDiv);\n              }\n              blankDiv.style.height = `${blankDivRect.height}px`;\n              blankDiv.style.width = `${blankDivRect.width}px`;\n              node.setAttribute('blankDiv', 'true'); // Makes removing easier\n              blankDivPos = i;\n            }\n            if (blankDivPos !== -1) {\n              childRect.y += blankDivRect.height;\n            }\n          }\n          // Insert so drag + drop behavior matches single-list case\n          draggableNodes.splice(blankDivPos, 0, blankDiv);\n          draggableNodesRects.splice(blankDivPos, 0, blankDivRect);\n          // Extend hitbox of droppable zone\n          rect.height += blankDivRect.height;\n        }\n      } else {\n        resetDroppableItem(droppableItem);\n        node.classList.add(styles.modifiers.dragging);\n        node.classList.add(styles.modifiers.dragOutside);\n      }\n    });\n    // Move hovering draggable and style it based on cursor position\n    setStyle(Object.assign(Object.assign({}, style), {\n      transform: `translate(${ev.pageX - startX}px, ${ev.pageY - startY}px)`\n    }));\n    setIsValidDrag(Boolean(hoveringDroppable));\n    // Iterate through sibling draggable nodes to reposition them and store correct hoveringIndex for onDrop\n    hoveringIndex = null;\n    if (hoveringDroppable) {\n      const {\n        draggableNodes,\n        draggableNodesRects\n      } = droppableItems.find(item => item.node === hoveringDroppable);\n      let lastTranslate = 0;\n      draggableNodes.forEach((n, i) => {\n        n.style.transition = 'transform 0.5s cubic-bezier(0.2, 1, 0.1, 1) 0s';\n        const rect = draggableNodesRects[i];\n        const halfway = rect.y + rect.height / 2;\n        let translateY = 0;\n        // Use offset for more interactive translations\n        if (startY < halfway && ev.pageY + (blankDivRect.height - startYOffset) > halfway) {\n          translateY -= blankDivRect.height;\n        } else if (startY >= halfway && ev.pageY - startYOffset <= halfway) {\n          translateY += blankDivRect.height;\n        }\n        // Clever way to find item currently hovering over\n        if (translateY <= lastTranslate && translateY < 0 || translateY > lastTranslate && translateY > 0) {\n          hoveringIndex = i;\n        }\n        n.style.transform = `translate(0, ${translateY}px`;\n        lastTranslate = translateY;\n      });\n    }\n    const {\n      source,\n      dest\n    } = getSourceAndDest();\n    onDragMove(source, dest);\n  };\n  const onDragStart = ev => {\n    // Default HTML drag and drop doesn't allow us to change what the thing\n    // being dragged looks like. Because of this we'll use prevent the default\n    // and use `mouseMove` and `mouseUp` instead\n    ev.preventDefault();\n    if (isDragging) {\n      // still in animation\n      return;\n    }\n    // Cache droppable and draggable nodes and their bounding rects\n    const dragging = ev.target;\n    const rect = dragging.getBoundingClientRect();\n    const droppableNodes = Array.from(document.querySelectorAll(`[data-pf-droppable=\"${zone}\"]`));\n    const droppableItems = droppableNodes.reduce((acc, cur) => {\n      cur.classList.add(styles.modifiers.dragging);\n      const draggableNodes = Array.from(cur.querySelectorAll(`[data-pf-draggable-zone=\"${zone}\"]`));\n      const isDraggingHost = cur.contains(dragging);\n      if (isDraggingHost) {\n        index = draggableNodes.indexOf(dragging);\n      }\n      const droppableItem = {\n        node: cur,\n        rect: cur.getBoundingClientRect(),\n        isDraggingHost,\n        // We don't want styles to apply to the left behind div in onMouseMoveWhileDragging\n        draggableNodes: draggableNodes.map(node => node === dragging ? node.cloneNode(false) : node),\n        draggableNodesRects: draggableNodes.map(node => node.getBoundingClientRect())\n      };\n      acc.push(droppableItem);\n      return acc;\n    }, []);\n    if (!onDrag({\n      droppableId,\n      index\n    })) {\n      // Consumer disallowed drag\n      return;\n    }\n    // Set initial style so future style mods take effect\n    style = Object.assign(Object.assign({}, style), {\n      top: rect.y,\n      left: rect.x,\n      width: rect.width,\n      height: rect.height,\n      '--pf-c-draggable--m-dragging--BackgroundColor': getInheritedBackgroundColor(dragging),\n      position: 'fixed',\n      zIndex: 5000\n    });\n    setStyle(style);\n    // Store event details\n    startX = ev.pageX;\n    startY = ev.pageY;\n    startYOffset = startY - rect.y;\n    setIsDragging(true);\n    mouseMoveListener = ev => onMouseMoveWhileDragging(ev, droppableItems, rect);\n    mouseUpListener = () => onMouseUpWhileDragging(droppableItems);\n    document.addEventListener('mousemove', mouseMoveListener);\n    document.addEventListener('mouseup', mouseUpListener);\n    // Comment out this line to debug while dragging by right clicking\n    // document.addEventListener('contextmenu', mouseUpListener);\n  };\n  const childProps = Object.assign({\n    'data-pf-draggable-zone': isDragging ? null : zone,\n    draggable: true,\n    className: css(styles.draggable, isDragging && styles.modifiers.dragging, !isValidDrag && styles.modifiers.dragOutside, className),\n    onDragStart,\n    onTransitionEnd,\n    style\n  }, props);\n  return React.createElement(React.Fragment, null, isDragging && React.createElement(\"div\", Object.assign({\n    draggable: true\n  }, props, {\n    style: Object.assign(Object.assign({}, styleProp), {\n      visibility: 'hidden'\n    })\n  }), children), hasNoWrapper ? React.cloneElement(children, childProps) : React.createElement(\"div\", Object.assign({}, childProps), children));\n};\nDraggable.displayName = 'Draggable';","map":{"version":3,"sources":["../../../../src/components/DragDrop/Draggable.tsx"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { __rest } from \"tslib\";\nimport * as React from 'react';\nimport { css } from '@patternfly/react-styles';\nimport styles from '@patternfly/react-styles/css/components/DragDrop/drag-drop';\nimport { DroppableContext } from './DroppableContext';\nimport { DragDropContext } from './DragDrop';\n// Browsers really like being different from each other.\nfunction getDefaultBackground() {\n    const div = document.createElement('div');\n    document.head.appendChild(div);\n    const bg = window.getComputedStyle(div).backgroundColor;\n    document.head.removeChild(div);\n    return bg;\n}\nfunction getInheritedBackgroundColor(el) {\n    const defaultStyle = getDefaultBackground();\n    const backgroundColor = window.getComputedStyle(el).backgroundColor;\n    if (backgroundColor !== defaultStyle) {\n        return backgroundColor;\n    }\n    else if (!el.parentElement) {\n        return defaultStyle;\n    }\n    return getInheritedBackgroundColor(el.parentElement);\n}\nfunction removeBlankDiv(node) {\n    if (node.getAttribute('blankDiv') === 'true') {\n        // eslint-disable-next-line @typescript-eslint/prefer-for-of\n        for (let i = 0; i < node.children.length; i++) {\n            const child = node.children[i];\n            if (child.getAttribute('blankDiv') === 'true') {\n                node.removeChild(child);\n                node.setAttribute('blankDiv', 'false');\n                break;\n            }\n        }\n    }\n}\n// Reset per-element state\nfunction resetDroppableItem(droppableItem) {\n    removeBlankDiv(droppableItem.node);\n    droppableItem.node.classList.remove(styles.modifiers.dragging);\n    droppableItem.node.classList.remove(styles.modifiers.dragOutside);\n    droppableItem.draggableNodes.forEach((n, i) => {\n        n.style.transform = '';\n        n.style.transition = '';\n        droppableItem.draggableNodesRects[i] = n.getBoundingClientRect();\n    });\n}\nfunction overlaps(ev, rect) {\n    return (ev.clientX > rect.x && ev.clientX < rect.x + rect.width && ev.clientY > rect.y && ev.clientY < rect.y + rect.height);\n}\nexport const Draggable = (_a) => {\n    var { className, children, style: styleProp = {}, hasNoWrapper = false } = _a, props = __rest(_a, [\"className\", \"children\", \"style\", \"hasNoWrapper\"]);\n    /* eslint-disable prefer-const */\n    let [style, setStyle] = React.useState(styleProp);\n    /* eslint-enable prefer-const */\n    const [isDragging, setIsDragging] = React.useState(false);\n    const [isValidDrag, setIsValidDrag] = React.useState(true);\n    const { zone, droppableId } = React.useContext(DroppableContext);\n    const { onDrag, onDragMove, onDrop } = React.useContext(DragDropContext);\n    // Some state is better just to leave as vars passed around between various callbacks\n    // You can only drag around one item at a time anyways...\n    let startX = 0;\n    let startY = 0;\n    let index = null; // Index of this draggable\n    let hoveringDroppable;\n    let hoveringIndex = null;\n    let mouseMoveListener;\n    let mouseUpListener;\n    // Makes it so dragging the _bottom_ of the item over the halfway of another moves it\n    let startYOffset = 0;\n    // After item returning to where it started animation completes\n    const onTransitionEnd = (_ev) => {\n        if (isDragging) {\n            setIsDragging(false);\n            setStyle(styleProp);\n        }\n    };\n    function getSourceAndDest() {\n        const hoveringDroppableId = hoveringDroppable ? hoveringDroppable.getAttribute('data-pf-droppableid') : null;\n        const source = {\n            droppableId,\n            index\n        };\n        const dest = hoveringDroppableId !== null && hoveringIndex !== null\n            ? {\n                droppableId: hoveringDroppableId,\n                index: hoveringIndex\n            }\n            : undefined;\n        return { source, dest, hoveringDroppableId };\n    }\n    const onMouseUpWhileDragging = (droppableItems) => {\n        droppableItems.forEach(resetDroppableItem);\n        document.removeEventListener('mousemove', mouseMoveListener);\n        document.removeEventListener('mouseup', mouseUpListener);\n        document.removeEventListener('contextmenu', mouseUpListener);\n        const { source, dest, hoveringDroppableId } = getSourceAndDest();\n        const consumerReordered = onDrop(source, dest);\n        if (consumerReordered && droppableId === hoveringDroppableId) {\n            setIsDragging(false);\n            setStyle(styleProp);\n        }\n        else if (!consumerReordered) {\n            // Animate item returning to where it started\n            setStyle(Object.assign(Object.assign({}, style), { transition: 'transform 0.5s cubic-bezier(0.2, 1, 0.1, 1) 0s', transform: '', background: styleProp.background, boxShadow: styleProp.boxShadow }));\n        }\n    };\n    // This is where the magic happens\n    const onMouseMoveWhileDragging = (ev, droppableItems, blankDivRect) => {\n        // Compute each time what droppable node we are hovering over\n        hoveringDroppable = null;\n        droppableItems.forEach(droppableItem => {\n            const { node, rect, isDraggingHost, draggableNodes, draggableNodesRects } = droppableItem;\n            if (overlaps(ev, rect)) {\n                // Add valid dropzone style\n                node.classList.remove(styles.modifiers.dragOutside);\n                hoveringDroppable = node;\n                // Check if we need to add a blank div row\n                if (node.getAttribute('blankDiv') !== 'true' && !isDraggingHost) {\n                    const blankDiv = document.createElement('div');\n                    blankDiv.setAttribute('blankDiv', 'true'); // Makes removing easier\n                    let blankDivPos = -1;\n                    for (let i = 0; i < draggableNodes.length; i++) {\n                        const childRect = draggableNodesRects[i];\n                        const isLast = i === draggableNodes.length - 1;\n                        const startOverlaps = childRect.y >= startY - startYOffset;\n                        if ((startOverlaps || isLast) && blankDivPos === -1) {\n                            if (isLast && !startOverlaps) {\n                                draggableNodes[i].after(blankDiv);\n                            }\n                            else {\n                                draggableNodes[i].before(blankDiv);\n                            }\n                            blankDiv.style.height = `${blankDivRect.height}px`;\n                            blankDiv.style.width = `${blankDivRect.width}px`;\n                            node.setAttribute('blankDiv', 'true'); // Makes removing easier\n                            blankDivPos = i;\n                        }\n                        if (blankDivPos !== -1) {\n                            childRect.y += blankDivRect.height;\n                        }\n                    }\n                    // Insert so drag + drop behavior matches single-list case\n                    draggableNodes.splice(blankDivPos, 0, blankDiv);\n                    draggableNodesRects.splice(blankDivPos, 0, blankDivRect);\n                    // Extend hitbox of droppable zone\n                    rect.height += blankDivRect.height;\n                }\n            }\n            else {\n                resetDroppableItem(droppableItem);\n                node.classList.add(styles.modifiers.dragging);\n                node.classList.add(styles.modifiers.dragOutside);\n            }\n        });\n        // Move hovering draggable and style it based on cursor position\n        setStyle(Object.assign(Object.assign({}, style), { transform: `translate(${ev.pageX - startX}px, ${ev.pageY - startY}px)` }));\n        setIsValidDrag(Boolean(hoveringDroppable));\n        // Iterate through sibling draggable nodes to reposition them and store correct hoveringIndex for onDrop\n        hoveringIndex = null;\n        if (hoveringDroppable) {\n            const { draggableNodes, draggableNodesRects } = droppableItems.find(item => item.node === hoveringDroppable);\n            let lastTranslate = 0;\n            draggableNodes.forEach((n, i) => {\n                n.style.transition = 'transform 0.5s cubic-bezier(0.2, 1, 0.1, 1) 0s';\n                const rect = draggableNodesRects[i];\n                const halfway = rect.y + rect.height / 2;\n                let translateY = 0;\n                // Use offset for more interactive translations\n                if (startY < halfway && ev.pageY + (blankDivRect.height - startYOffset) > halfway) {\n                    translateY -= blankDivRect.height;\n                }\n                else if (startY >= halfway && ev.pageY - startYOffset <= halfway) {\n                    translateY += blankDivRect.height;\n                }\n                // Clever way to find item currently hovering over\n                if ((translateY <= lastTranslate && translateY < 0) || (translateY > lastTranslate && translateY > 0)) {\n                    hoveringIndex = i;\n                }\n                n.style.transform = `translate(0, ${translateY}px`;\n                lastTranslate = translateY;\n            });\n        }\n        const { source, dest } = getSourceAndDest();\n        onDragMove(source, dest);\n    };\n    const onDragStart = (ev) => {\n        // Default HTML drag and drop doesn't allow us to change what the thing\n        // being dragged looks like. Because of this we'll use prevent the default\n        // and use `mouseMove` and `mouseUp` instead\n        ev.preventDefault();\n        if (isDragging) {\n            // still in animation\n            return;\n        }\n        // Cache droppable and draggable nodes and their bounding rects\n        const dragging = ev.target;\n        const rect = dragging.getBoundingClientRect();\n        const droppableNodes = Array.from(document.querySelectorAll(`[data-pf-droppable=\"${zone}\"]`));\n        const droppableItems = droppableNodes.reduce((acc, cur) => {\n            cur.classList.add(styles.modifiers.dragging);\n            const draggableNodes = Array.from(cur.querySelectorAll(`[data-pf-draggable-zone=\"${zone}\"]`));\n            const isDraggingHost = cur.contains(dragging);\n            if (isDraggingHost) {\n                index = draggableNodes.indexOf(dragging);\n            }\n            const droppableItem = {\n                node: cur,\n                rect: cur.getBoundingClientRect(),\n                isDraggingHost,\n                // We don't want styles to apply to the left behind div in onMouseMoveWhileDragging\n                draggableNodes: draggableNodes.map(node => (node === dragging ? node.cloneNode(false) : node)),\n                draggableNodesRects: draggableNodes.map(node => node.getBoundingClientRect())\n            };\n            acc.push(droppableItem);\n            return acc;\n        }, []);\n        if (!onDrag({ droppableId, index })) {\n            // Consumer disallowed drag\n            return;\n        }\n        // Set initial style so future style mods take effect\n        style = Object.assign(Object.assign({}, style), { top: rect.y, left: rect.x, width: rect.width, height: rect.height, '--pf-c-draggable--m-dragging--BackgroundColor': getInheritedBackgroundColor(dragging), position: 'fixed', zIndex: 5000 });\n        setStyle(style);\n        // Store event details\n        startX = ev.pageX;\n        startY = ev.pageY;\n        startYOffset = startY - rect.y;\n        setIsDragging(true);\n        mouseMoveListener = ev => onMouseMoveWhileDragging(ev, droppableItems, rect);\n        mouseUpListener = () => onMouseUpWhileDragging(droppableItems);\n        document.addEventListener('mousemove', mouseMoveListener);\n        document.addEventListener('mouseup', mouseUpListener);\n        // Comment out this line to debug while dragging by right clicking\n        // document.addEventListener('contextmenu', mouseUpListener);\n    };\n    const childProps = Object.assign({ 'data-pf-draggable-zone': isDragging ? null : zone, draggable: true, className: css(styles.draggable, isDragging && styles.modifiers.dragging, !isValidDrag && styles.modifiers.dragOutside, className), onDragStart,\n        onTransitionEnd,\n        style }, props);\n    return (React.createElement(React.Fragment, null,\n        isDragging && (React.createElement(\"div\", Object.assign({ draggable: true }, props, { style: Object.assign(Object.assign({}, styleProp), { visibility: 'hidden' }) }), children)),\n        hasNoWrapper ? (React.cloneElement(children, childProps)) : (React.createElement(\"div\", Object.assign({}, childProps), children))));\n};\nDraggable.displayName = 'Draggable';\n//# sourceMappingURL=Draggable.js.map"]},"metadata":{},"sourceType":"module"}