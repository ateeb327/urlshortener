{"ast":null,"code":"/**\n * body-row.tsx\n *\n * Forked from reactabular-table version 8.14.0\n * https://github.com/reactabular/reactabular/tree/v8.14.0/packages/reactabular-table/src\n */\nimport isEqual from 'lodash/isEqual';\nimport * as React from 'react';\nimport { columnsAreEqual } from './columns-are-equal';\nimport { evaluateFormatters } from './evaluate-formatters';\nimport { evaluateTransforms } from './evaluate-transforms';\nimport { mergeProps } from './merge-props';\nexport class BodyRow extends React.Component {\n  shouldComponentUpdate(nextProps) {\n    const {\n      columns,\n      rowData\n    } = this.props;\n    // Check for row based override.\n    const {\n      renderers\n    } = nextProps;\n    if (renderers && renderers.row && renderers.row.shouldComponentUpdate) {\n      if (typeof renderers.row.shouldComponentUpdate === 'function') {\n        return renderers.row.shouldComponentUpdate.call(this, nextProps, {}, {});\n      }\n      return true;\n    }\n    return !(columnsAreEqual(columns, nextProps.columns) && isEqual(rowData, nextProps.rowData));\n  }\n  render() {\n    const {\n      columns,\n      renderers,\n      onRow,\n      rowKey,\n      rowIndex,\n      rowData\n    } = this.props;\n    return React.createElement(renderers.row, onRow(rowData, {\n      rowIndex,\n      rowKey\n    }), columns.map((column, columnIndex) => {\n      const {\n        property,\n        cell,\n        props\n      } = column;\n      const evaluatedProperty = property || cell && cell.property;\n      const {\n        transforms = [],\n        formatters = []\n      } = cell || {};\n      const extraParameters = {\n        columnIndex,\n        property: evaluatedProperty,\n        column,\n        rowData,\n        rowIndex,\n        rowKey\n      };\n      const transformed = evaluateTransforms(transforms, rowData[evaluatedProperty], extraParameters);\n      if (!transformed) {\n        // eslint-disable-next-line no-console\n        console.warn('Table.Body - Failed to receive a transformed result');\n      }\n      let additionalFormaters = [];\n      if (rowData[evaluatedProperty]) {\n        additionalFormaters = rowData[evaluatedProperty].formatters;\n      }\n      return React.createElement(renderers.cell, Object.assign({\n        key: `col-${columnIndex}-row-${rowIndex}`\n      }, mergeProps(props, cell && cell.props, transformed)), !rowData.fullWidth && transformed.children || evaluateFormatters([...formatters, ...additionalFormaters])(rowData[`_${evaluatedProperty}`] || rowData[evaluatedProperty], extraParameters));\n    }));\n  }\n}\nBodyRow.displayName = 'BodyRow';\nBodyRow.defaultProps = {\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  onRow: (...args) => ({})\n};","map":{"version":3,"sources":["../../../../../src/components/Table/base/body-row.tsx"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\n * body-row.tsx\n *\n * Forked from reactabular-table version 8.14.0\n * https://github.com/reactabular/reactabular/tree/v8.14.0/packages/reactabular-table/src\n */\nimport isEqual from 'lodash/isEqual';\nimport * as React from 'react';\nimport { columnsAreEqual } from './columns-are-equal';\nimport { evaluateFormatters } from './evaluate-formatters';\nimport { evaluateTransforms } from './evaluate-transforms';\nimport { mergeProps } from './merge-props';\nexport class BodyRow extends React.Component {\n    shouldComponentUpdate(nextProps) {\n        const { columns, rowData } = this.props;\n        // Check for row based override.\n        const { renderers } = nextProps;\n        if (renderers && renderers.row && renderers.row.shouldComponentUpdate) {\n            if (typeof renderers.row.shouldComponentUpdate === 'function') {\n                return renderers.row.shouldComponentUpdate.call(this, nextProps, {}, {});\n            }\n            return true;\n        }\n        return !(columnsAreEqual(columns, nextProps.columns) && isEqual(rowData, nextProps.rowData));\n    }\n    render() {\n        const { columns, renderers, onRow, rowKey, rowIndex, rowData } = this.props;\n        return React.createElement(renderers.row, onRow(rowData, { rowIndex, rowKey }), columns.map((column, columnIndex) => {\n            const { property, cell, props } = column;\n            const evaluatedProperty = (property || (cell && cell.property));\n            const { transforms = [], formatters = [] } = cell || {};\n            const extraParameters = {\n                columnIndex,\n                property: evaluatedProperty,\n                column,\n                rowData,\n                rowIndex,\n                rowKey\n            };\n            const transformed = evaluateTransforms(transforms, rowData[evaluatedProperty], extraParameters);\n            if (!transformed) {\n                // eslint-disable-next-line no-console\n                console.warn('Table.Body - Failed to receive a transformed result');\n            }\n            let additionalFormaters = [];\n            if (rowData[evaluatedProperty]) {\n                additionalFormaters = rowData[evaluatedProperty].formatters;\n            }\n            return React.createElement(renderers.cell, Object.assign({ key: `col-${columnIndex}-row-${rowIndex}` }, mergeProps(props, cell && cell.props, transformed)), (!rowData.fullWidth && transformed.children) ||\n                evaluateFormatters([...formatters, ...additionalFormaters])(rowData[`_${evaluatedProperty}`] || rowData[evaluatedProperty], extraParameters));\n        }));\n    }\n}\nBodyRow.displayName = 'BodyRow';\nBodyRow.defaultProps = {\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    onRow: (...args) => ({})\n};\n//# sourceMappingURL=body-row.js.map"]},"metadata":{},"sourceType":"module"}