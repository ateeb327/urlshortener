{"ast":null,"code":"import getBasePlacement from '../utils/getBasePlacement';\nimport getLayoutRect from '../dom-utils/getLayoutRect';\nimport contains from '../dom-utils/contains';\nimport getOffsetParent from '../dom-utils/getOffsetParent';\nimport getMainAxisFromPlacement from '../utils/getMainAxisFromPlacement';\nimport within from '../utils/within';\nimport mergePaddingObject from '../utils/mergePaddingObject';\nimport expandToHashMap from '../utils/expandToHashMap';\nimport { left, right, basePlacements, top, bottom } from '../enums';\nimport { isHTMLElement } from '../dom-utils/instanceOf';\n/**\n *\n */\nfunction arrow({\n  state,\n  name\n}) {\n  const arrowElement = state.elements.arrow;\n  const popperOffsets = state.modifiersData.popperOffsets;\n  const basePlacement = getBasePlacement(state.placement);\n  const axis = getMainAxisFromPlacement(basePlacement);\n  const isVertical = [left, right].indexOf(basePlacement) >= 0;\n  const len = isVertical ? 'height' : 'width';\n  if (!arrowElement || !popperOffsets) {\n    return;\n  }\n  const paddingObject = state.modifiersData[`${name}#persistent`].padding;\n  const arrowRect = getLayoutRect(arrowElement);\n  const minProp = axis === 'y' ? top : left;\n  const maxProp = axis === 'y' ? bottom : right;\n  const endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets[axis] - state.rects.popper[len];\n  const startDiff = popperOffsets[axis] - state.rects.reference[axis];\n  const arrowOffsetParent = getOffsetParent(arrowElement);\n  const clientSize = arrowOffsetParent ? axis === 'y' ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;\n  const centerToReference = endDiff / 2 - startDiff / 2;\n  // Make sure the arrow doesn't overflow the popper if the center point is\n  // outside of the popper bounds\n  const min = paddingObject[minProp];\n  const max = clientSize - arrowRect[len] - paddingObject[maxProp];\n  const center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;\n  const offset = within(min, center, max);\n  // Prevents breaking syntax highlighting...\n  const axisProp = axis;\n  state.modifiersData[name] = {\n    [axisProp]: offset,\n    centerOffset: offset - center\n  };\n}\n/**\n *\n */\nfunction effect({\n  state,\n  options,\n  name\n}) {\n  let {\n    element: arrowElement = '[data-popper-arrow]',\n    padding = 0\n  } = options;\n  if (arrowElement == null) {\n    return;\n  }\n  // CSS selector\n  if (typeof arrowElement === 'string') {\n    arrowElement = state.elements.popper.querySelector(arrowElement);\n    if (!arrowElement) {\n      return;\n    }\n  }\n  if (false /* __DEV__*/) {\n    if (!isHTMLElement(arrowElement)) {\n      console.error(['Popper: \"arrow\" element must be an HTMLElement (not an SVGElement).', 'To use an SVG arrow, wrap it in an HTMLElement that will be used as', 'the arrow.'].join(' '));\n    }\n  }\n  if (!contains(state.elements.popper, arrowElement)) {\n    if (false /* __DEV__*/) {\n      console.error(['Popper: \"arrow\" modifier\\'s `element` must be a child of the popper', 'element.'].join(' '));\n    }\n    return;\n  }\n  state.elements.arrow = arrowElement;\n  state.modifiersData[`${name}#persistent`] = {\n    padding: mergePaddingObject(typeof padding !== 'number' ? padding : expandToHashMap(padding, basePlacements))\n  };\n}\nexport default {\n  name: 'arrow',\n  enabled: true,\n  phase: 'main',\n  fn: arrow,\n  effect,\n  requires: ['popperOffsets'],\n  requiresIfExists: ['preventOverflow']\n};","map":{"version":3,"sources":["../../../../../../../src/helpers/Popper/thirdparty/popper-core/modifiers/arrow.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import getBasePlacement from '../utils/getBasePlacement';\nimport getLayoutRect from '../dom-utils/getLayoutRect';\nimport contains from '../dom-utils/contains';\nimport getOffsetParent from '../dom-utils/getOffsetParent';\nimport getMainAxisFromPlacement from '../utils/getMainAxisFromPlacement';\nimport within from '../utils/within';\nimport mergePaddingObject from '../utils/mergePaddingObject';\nimport expandToHashMap from '../utils/expandToHashMap';\nimport { left, right, basePlacements, top, bottom } from '../enums';\nimport { isHTMLElement } from '../dom-utils/instanceOf';\n/**\n *\n */\nfunction arrow({ state, name }) {\n    const arrowElement = state.elements.arrow;\n    const popperOffsets = state.modifiersData.popperOffsets;\n    const basePlacement = getBasePlacement(state.placement);\n    const axis = getMainAxisFromPlacement(basePlacement);\n    const isVertical = [left, right].indexOf(basePlacement) >= 0;\n    const len = isVertical ? 'height' : 'width';\n    if (!arrowElement || !popperOffsets) {\n        return;\n    }\n    const paddingObject = state.modifiersData[`${name}#persistent`].padding;\n    const arrowRect = getLayoutRect(arrowElement);\n    const minProp = axis === 'y' ? top : left;\n    const maxProp = axis === 'y' ? bottom : right;\n    const endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets[axis] - state.rects.popper[len];\n    const startDiff = popperOffsets[axis] - state.rects.reference[axis];\n    const arrowOffsetParent = getOffsetParent(arrowElement);\n    const clientSize = arrowOffsetParent\n        ? axis === 'y'\n            ? arrowOffsetParent.clientHeight || 0\n            : arrowOffsetParent.clientWidth || 0\n        : 0;\n    const centerToReference = endDiff / 2 - startDiff / 2;\n    // Make sure the arrow doesn't overflow the popper if the center point is\n    // outside of the popper bounds\n    const min = paddingObject[minProp];\n    const max = clientSize - arrowRect[len] - paddingObject[maxProp];\n    const center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;\n    const offset = within(min, center, max);\n    // Prevents breaking syntax highlighting...\n    const axisProp = axis;\n    state.modifiersData[name] = {\n        [axisProp]: offset,\n        centerOffset: offset - center\n    };\n}\n/**\n *\n */\nfunction effect({ state, options, name }) {\n    let { element: arrowElement = '[data-popper-arrow]', padding = 0 } = options;\n    if (arrowElement == null) {\n        return;\n    }\n    // CSS selector\n    if (typeof arrowElement === 'string') {\n        arrowElement = state.elements.popper.querySelector(arrowElement);\n        if (!arrowElement) {\n            return;\n        }\n    }\n    if (false /* __DEV__*/) {\n        if (!isHTMLElement(arrowElement)) {\n            console.error([\n                'Popper: \"arrow\" element must be an HTMLElement (not an SVGElement).',\n                'To use an SVG arrow, wrap it in an HTMLElement that will be used as',\n                'the arrow.'\n            ].join(' '));\n        }\n    }\n    if (!contains(state.elements.popper, arrowElement)) {\n        if (false /* __DEV__*/) {\n            console.error(['Popper: \"arrow\" modifier\\'s `element` must be a child of the popper', 'element.'].join(' '));\n        }\n        return;\n    }\n    state.elements.arrow = arrowElement;\n    state.modifiersData[`${name}#persistent`] = {\n        padding: mergePaddingObject(typeof padding !== 'number' ? padding : expandToHashMap(padding, basePlacements))\n    };\n}\nexport default {\n    name: 'arrow',\n    enabled: true,\n    phase: 'main',\n    fn: arrow,\n    effect,\n    requires: ['popperOffsets'],\n    requiresIfExists: ['preventOverflow']\n};\n//# sourceMappingURL=arrow.js.map"]},"metadata":{},"sourceType":"module"}