{"ast":null,"code":"// @ts-nocheck\nimport { top, left, right, bottom, start } from '../enums';\nimport getBasePlacement from '../utils/getBasePlacement';\nimport getMainAxisFromPlacement from '../utils/getMainAxisFromPlacement';\nimport getAltAxis from '../utils/getAltAxis';\nimport within from '../utils/within';\nimport getLayoutRect from '../dom-utils/getLayoutRect';\nimport getOffsetParent from '../dom-utils/getOffsetParent';\nimport detectOverflow from '../utils/detectOverflow';\nimport getVariation from '../utils/getVariation';\nimport getFreshSideObject from '../utils/getFreshSideObject';\n/**\n *\n */\nfunction preventOverflow({\n  state,\n  options,\n  name\n}) {\n  const {\n    mainAxis: checkMainAxis = true,\n    altAxis: checkAltAxis = false,\n    boundary,\n    rootBoundary,\n    altBoundary,\n    padding,\n    tether = true,\n    tetherOffset = 0\n  } = options;\n  const overflow = detectOverflow(state, {\n    boundary,\n    rootBoundary,\n    padding,\n    altBoundary\n  });\n  const basePlacement = getBasePlacement(state.placement);\n  const variation = getVariation(state.placement);\n  const isBasePlacement = !variation;\n  const mainAxis = getMainAxisFromPlacement(basePlacement);\n  const altAxis = getAltAxis(mainAxis);\n  const popperOffsets = state.modifiersData.popperOffsets;\n  const referenceRect = state.rects.reference;\n  const popperRect = state.rects.popper;\n  const tetherOffsetValue = typeof tetherOffset === 'function' ? tetherOffset(Object.assign(Object.assign({}, state.rects), {\n    placement: state.placement\n  })) : tetherOffset;\n  const data = {\n    x: 0,\n    y: 0\n  };\n  if (!popperOffsets) {\n    return;\n  }\n  if (checkMainAxis) {\n    const mainSide = mainAxis === 'y' ? top : left;\n    const altSide = mainAxis === 'y' ? bottom : right;\n    const len = mainAxis === 'y' ? 'height' : 'width';\n    const offset = popperOffsets[mainAxis];\n    const min = popperOffsets[mainAxis] + overflow[mainSide];\n    const max = popperOffsets[mainAxis] - overflow[altSide];\n    const additive = tether ? -popperRect[len] / 2 : 0;\n    const minLen = variation === start ? referenceRect[len] : popperRect[len];\n    const maxLen = variation === start ? -popperRect[len] : -referenceRect[len];\n    // We need to include the arrow in the calculation so the arrow doesn't go\n    // outside the reference bounds\n    const arrowElement = state.elements.arrow;\n    const arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {\n      width: 0,\n      height: 0\n    };\n    const arrowPaddingObject = state.modifiersData['arrow#persistent'] ? state.modifiersData['arrow#persistent'].padding : getFreshSideObject();\n    const arrowPaddingMin = arrowPaddingObject[mainSide];\n    const arrowPaddingMax = arrowPaddingObject[altSide];\n    // If the reference length is smaller than the arrow length, we don't want\n    // to include its full size in the calculation. If the reference is small\n    // and near the edge of a boundary, the popper can overflow even if the\n    // reference is not overflowing as well (e.g. virtual elements with no\n    // width or height)\n    const arrowLen = within(0, referenceRect[len], arrowRect[len]);\n    const minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - tetherOffsetValue : minLen - arrowLen - arrowPaddingMin - tetherOffsetValue;\n    const maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + tetherOffsetValue : maxLen + arrowLen + arrowPaddingMax + tetherOffsetValue;\n    const arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);\n    const clientOffset = arrowOffsetParent ? mainAxis === 'y' ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;\n    const offsetModifierValue = state.modifiersData.offset ? state.modifiersData.offset[state.placement][mainAxis] : 0;\n    const tetherMin = popperOffsets[mainAxis] + minOffset - offsetModifierValue - clientOffset;\n    const tetherMax = popperOffsets[mainAxis] + maxOffset - offsetModifierValue;\n    const preventedOffset = within(tether ? Math.min(min, tetherMin) : min, offset, tether ? Math.max(max, tetherMax) : max);\n    popperOffsets[mainAxis] = preventedOffset;\n    data[mainAxis] = preventedOffset - offset;\n  }\n  if (checkAltAxis) {\n    const mainSide = mainAxis === 'x' ? top : left;\n    const altSide = mainAxis === 'x' ? bottom : right;\n    const offset = popperOffsets[altAxis];\n    const min = offset + overflow[mainSide];\n    const max = offset - overflow[altSide];\n    const preventedOffset = within(min, offset, max);\n    popperOffsets[altAxis] = preventedOffset;\n    data[altAxis] = preventedOffset - offset;\n  }\n  state.modifiersData[name] = data;\n}\nexport default {\n  name: 'preventOverflow',\n  enabled: true,\n  phase: 'main',\n  fn: preventOverflow,\n  requiresIfExists: ['offset']\n};","map":{"version":3,"sources":["../../../../../../../src/helpers/Popper/thirdparty/popper-core/modifiers/preventOverflow.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["// @ts-nocheck\nimport { top, left, right, bottom, start } from '../enums';\nimport getBasePlacement from '../utils/getBasePlacement';\nimport getMainAxisFromPlacement from '../utils/getMainAxisFromPlacement';\nimport getAltAxis from '../utils/getAltAxis';\nimport within from '../utils/within';\nimport getLayoutRect from '../dom-utils/getLayoutRect';\nimport getOffsetParent from '../dom-utils/getOffsetParent';\nimport detectOverflow from '../utils/detectOverflow';\nimport getVariation from '../utils/getVariation';\nimport getFreshSideObject from '../utils/getFreshSideObject';\n/**\n *\n */\nfunction preventOverflow({ state, options, name }) {\n    const { mainAxis: checkMainAxis = true, altAxis: checkAltAxis = false, boundary, rootBoundary, altBoundary, padding, tether = true, tetherOffset = 0 } = options;\n    const overflow = detectOverflow(state, {\n        boundary,\n        rootBoundary,\n        padding,\n        altBoundary\n    });\n    const basePlacement = getBasePlacement(state.placement);\n    const variation = getVariation(state.placement);\n    const isBasePlacement = !variation;\n    const mainAxis = getMainAxisFromPlacement(basePlacement);\n    const altAxis = getAltAxis(mainAxis);\n    const popperOffsets = state.modifiersData.popperOffsets;\n    const referenceRect = state.rects.reference;\n    const popperRect = state.rects.popper;\n    const tetherOffsetValue = typeof tetherOffset === 'function'\n        ? tetherOffset(Object.assign(Object.assign({}, state.rects), { placement: state.placement }))\n        : tetherOffset;\n    const data = { x: 0, y: 0 };\n    if (!popperOffsets) {\n        return;\n    }\n    if (checkMainAxis) {\n        const mainSide = mainAxis === 'y' ? top : left;\n        const altSide = mainAxis === 'y' ? bottom : right;\n        const len = mainAxis === 'y' ? 'height' : 'width';\n        const offset = popperOffsets[mainAxis];\n        const min = popperOffsets[mainAxis] + overflow[mainSide];\n        const max = popperOffsets[mainAxis] - overflow[altSide];\n        const additive = tether ? -popperRect[len] / 2 : 0;\n        const minLen = variation === start ? referenceRect[len] : popperRect[len];\n        const maxLen = variation === start ? -popperRect[len] : -referenceRect[len];\n        // We need to include the arrow in the calculation so the arrow doesn't go\n        // outside the reference bounds\n        const arrowElement = state.elements.arrow;\n        const arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : { width: 0, height: 0 };\n        const arrowPaddingObject = state.modifiersData['arrow#persistent']\n            ? state.modifiersData['arrow#persistent'].padding\n            : getFreshSideObject();\n        const arrowPaddingMin = arrowPaddingObject[mainSide];\n        const arrowPaddingMax = arrowPaddingObject[altSide];\n        // If the reference length is smaller than the arrow length, we don't want\n        // to include its full size in the calculation. If the reference is small\n        // and near the edge of a boundary, the popper can overflow even if the\n        // reference is not overflowing as well (e.g. virtual elements with no\n        // width or height)\n        const arrowLen = within(0, referenceRect[len], arrowRect[len]);\n        const minOffset = isBasePlacement\n            ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - tetherOffsetValue\n            : minLen - arrowLen - arrowPaddingMin - tetherOffsetValue;\n        const maxOffset = isBasePlacement\n            ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + tetherOffsetValue\n            : maxLen + arrowLen + arrowPaddingMax + tetherOffsetValue;\n        const arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);\n        const clientOffset = arrowOffsetParent\n            ? mainAxis === 'y'\n                ? arrowOffsetParent.clientTop || 0\n                : arrowOffsetParent.clientLeft || 0\n            : 0;\n        const offsetModifierValue = state.modifiersData.offset ? state.modifiersData.offset[state.placement][mainAxis] : 0;\n        const tetherMin = popperOffsets[mainAxis] + minOffset - offsetModifierValue - clientOffset;\n        const tetherMax = popperOffsets[mainAxis] + maxOffset - offsetModifierValue;\n        const preventedOffset = within(tether ? Math.min(min, tetherMin) : min, offset, tether ? Math.max(max, tetherMax) : max);\n        popperOffsets[mainAxis] = preventedOffset;\n        data[mainAxis] = preventedOffset - offset;\n    }\n    if (checkAltAxis) {\n        const mainSide = mainAxis === 'x' ? top : left;\n        const altSide = mainAxis === 'x' ? bottom : right;\n        const offset = popperOffsets[altAxis];\n        const min = offset + overflow[mainSide];\n        const max = offset - overflow[altSide];\n        const preventedOffset = within(min, offset, max);\n        popperOffsets[altAxis] = preventedOffset;\n        data[altAxis] = preventedOffset - offset;\n    }\n    state.modifiersData[name] = data;\n}\nexport default {\n    name: 'preventOverflow',\n    enabled: true,\n    phase: 'main',\n    fn: preventOverflow,\n    requiresIfExists: ['offset']\n};\n//# sourceMappingURL=preventOverflow.js.map"]},"metadata":{},"sourceType":"module"}