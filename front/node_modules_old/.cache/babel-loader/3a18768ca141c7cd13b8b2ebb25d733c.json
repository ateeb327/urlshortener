{"ast":null,"code":"import getBasePlacement from '../utils/getBasePlacement';\nimport { top, left, right, placements } from '../enums';\n/**\n * @param placement\n * @param rects\n * @param offset\n */\nexport function distanceAndSkiddingToXY(placement, rects, offset) {\n  const basePlacement = getBasePlacement(placement);\n  const invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;\n  let [skidding, distance] = typeof offset === 'function' ? offset(Object.assign(Object.assign({}, rects), {\n    placement\n  })) : offset;\n  skidding = skidding || 0;\n  distance = (distance || 0) * invertDistance;\n  return [left, right].indexOf(basePlacement) >= 0 ? {\n    x: distance,\n    y: skidding\n  } : {\n    x: skidding,\n    y: distance\n  };\n}\n/**\n *\n */\nfunction offset({\n  state,\n  options,\n  name\n}) {\n  const {\n    offset = [0, 0]\n  } = options;\n  const data = placements.reduce((acc, placement) => {\n    acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset);\n    return acc;\n  }, {});\n  const {\n    x,\n    y\n  } = data[state.placement];\n  if (state.modifiersData.popperOffsets != null) {\n    state.modifiersData.popperOffsets.x += x;\n    state.modifiersData.popperOffsets.y += y;\n  }\n  state.modifiersData[name] = data;\n}\nexport default {\n  name: 'offset',\n  enabled: true,\n  phase: 'main',\n  requires: ['popperOffsets'],\n  fn: offset\n};","map":{"version":3,"sources":["../../../../../../../src/helpers/Popper/thirdparty/popper-core/modifiers/offset.ts"],"names":[],"mappings":"AAGA,OAAO,gBAAgB,MAAM,2BAA2B;AACxD,SAAS,GAAG,EAAE,IAAI,EAAE,KAAK,EAAE,UAAU,QAAQ,UAAU;AAevD;;;;AAIG;AACH,OAAM,SAAU,uBAAuB,CACrC,SAAoB,EACpB,KAAwC,EACxC,MAAc,EAAA;EAEd,MAAM,aAAa,GAAG,gBAAgB,CAAC,SAAS,CAAC;EACjD,MAAM,cAAc,GAAG,CAAC,IAAI,EAAE,GAAG,CAAC,CAAC,OAAO,CAAC,aAAa,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC;EAEvE,IAAI,CAAC,QAAQ,EAAE,QAAQ,CAAC,GACtB,OAAO,MAAM,KAAK,UAAU,GACxB,MAAM,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,CAAA,CAAA,EACD,KAAK,CAAA,EAAA;IACR;EAAS,CAAA,CAAA,CACT,GACF,MAAM;EAEZ,QAAQ,GAAG,QAAQ,IAAI,CAAC;EACxB,QAAQ,GAAG,CAAC,QAAQ,IAAI,CAAC,IAAI,cAAc;EAE3C,OAAO,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC,OAAO,CAAC,aAAa,CAAC,IAAI,CAAC,GAAG;IAAE,CAAC,EAAE,QAAQ;IAAE,CAAC,EAAE;EAAQ,CAAE,GAAG;IAAE,CAAC,EAAE,QAAQ;IAAE,CAAC,EAAE;EAAQ,CAAE;AAChH;AAEA;;AAEG;AACH,SAAS,MAAM,CAAC;EAAE,KAAK;EAAE,OAAO;EAAE;AAAI,CAA8B,EAAA;EAClE,MAAM;IAAE,MAAM,GAAG,CAAC,CAAC,EAAE,CAAC;EAAC,CAAE,GAAG,OAAO;EAEnC,MAAM,IAAI,GAAG,UAAU,CAAC,MAAM,CAAC,CAAC,GAAG,EAAE,SAAS,KAAI;IAChD,GAAG,CAAC,SAAS,CAAC,GAAG,uBAAuB,CAAC,SAAS,EAAE,KAAK,CAAC,KAAK,EAAE,MAAM,CAAC;IACxE,OAAO,GAAG;EACZ,CAAC,EAAE,CAAA,CAAE,CAAC;EAEN,MAAM;IAAE,CAAC;IAAE;EAAC,CAAE,GAAG,IAAI,CAAC,KAAK,CAAC,SAAS,CAAC;EAEtC,IAAI,KAAK,CAAC,aAAa,CAAC,aAAa,IAAI,IAAI,EAAE;IAC7C,KAAK,CAAC,aAAa,CAAC,aAAa,CAAC,CAAC,IAAI,CAAC;IACxC,KAAK,CAAC,aAAa,CAAC,aAAa,CAAC,CAAC,IAAI,CAAC;EACzC;EAED,KAAK,CAAC,aAAa,CAAC,IAAI,CAAC,GAAG,IAAI;AAClC;AAIA,eAAe;EACb,IAAI,EAAE,QAAQ;EACd,OAAO,EAAE,IAAI;EACb,KAAK,EAAE,MAAM;EACb,QAAQ,EAAE,CAAC,eAAe,CAAC;EAC3B,EAAE,EAAE;CACa","sourceRoot":"","sourcesContent":["import getBasePlacement from '../utils/getBasePlacement';\nimport { top, left, right, placements } from '../enums';\n/**\n * @param placement\n * @param rects\n * @param offset\n */\nexport function distanceAndSkiddingToXY(placement, rects, offset) {\n    const basePlacement = getBasePlacement(placement);\n    const invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;\n    let [skidding, distance] = typeof offset === 'function'\n        ? offset(Object.assign(Object.assign({}, rects), { placement }))\n        : offset;\n    skidding = skidding || 0;\n    distance = (distance || 0) * invertDistance;\n    return [left, right].indexOf(basePlacement) >= 0 ? { x: distance, y: skidding } : { x: skidding, y: distance };\n}\n/**\n *\n */\nfunction offset({ state, options, name }) {\n    const { offset = [0, 0] } = options;\n    const data = placements.reduce((acc, placement) => {\n        acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset);\n        return acc;\n    }, {});\n    const { x, y } = data[state.placement];\n    if (state.modifiersData.popperOffsets != null) {\n        state.modifiersData.popperOffsets.x += x;\n        state.modifiersData.popperOffsets.y += y;\n    }\n    state.modifiersData[name] = data;\n}\nexport default {\n    name: 'offset',\n    enabled: true,\n    phase: 'main',\n    requires: ['popperOffsets'],\n    fn: offset\n};\n//# sourceMappingURL=offset.js.map"]},"metadata":{},"sourceType":"module"}