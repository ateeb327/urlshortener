{"ast":null,"code":"import getNodeName from '../dom-utils/getNodeName';\nimport { isHTMLElement } from '../dom-utils/instanceOf';\n// This modifier takes the styles prepared by the `computeStyles` modifier\n// and applies them to the HTMLElements such as popper and arrow\n/**\n *\n */\nfunction applyStyles({\n  state\n}) {\n  Object.keys(state.elements).forEach(name => {\n    const style = state.styles[name] || {};\n    const attributes = state.attributes[name] || {};\n    const element = state.elements[name];\n    // arrow is optional + virtual elements\n    if (!isHTMLElement(element) || !getNodeName(element)) {\n      return;\n    }\n    // Flow doesn't support to extend this property, but it's the most\n    // effective way to apply styles to an HTMLElement\n    // $FlowFixMe\n    Object.assign(element.style, style);\n    Object.keys(attributes).forEach(name => {\n      const value = attributes[name];\n      if (value === false) {\n        element.removeAttribute(name);\n      } else {\n        element.setAttribute(name, value === true ? '' : value);\n      }\n    });\n  });\n}\n/**\n *\n */\nfunction effect({\n  state\n}) {\n  const initialStyles = {\n    popper: {\n      position: state.options.strategy,\n      left: '0',\n      top: '0',\n      margin: '0'\n    },\n    arrow: {\n      position: 'absolute'\n    },\n    reference: {}\n  };\n  Object.assign(state.elements.popper.style, initialStyles.popper);\n  if (state.elements.arrow) {\n    Object.assign(state.elements.arrow.style, initialStyles.arrow);\n  }\n  return () => {\n    Object.keys(state.elements).forEach(name => {\n      const element = state.elements[name];\n      const attributes = state.attributes[name] || {};\n      const styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]);\n      // Set all values to an empty string to unset them\n      const style = styleProperties.reduce((style, property) => {\n        style[property] = '';\n        return style;\n      }, {});\n      // arrow is optional + virtual elements\n      if (!isHTMLElement(element) || !getNodeName(element)) {\n        return;\n      }\n      // Flow doesn't support to extend this property, but it's the most\n      // effective way to apply styles to an HTMLElement\n      // $FlowFixMe\n      Object.assign(element.style, style);\n      Object.keys(attributes).forEach(attribute => {\n        element.removeAttribute(attribute);\n      });\n    });\n  };\n}\nexport default {\n  name: 'applyStyles',\n  enabled: true,\n  phase: 'write',\n  fn: applyStyles,\n  effect,\n  requires: ['computeStyles']\n};","map":{"version":3,"sources":["../../../../../../../src/helpers/Popper/thirdparty/popper-core/modifiers/applyStyles.ts"],"names":[],"mappings":"AAEA,OAAO,WAAW,MAAM,0BAA0B;AAClD,SAAS,aAAa,QAAQ,yBAAyB;AAEvD;AACA;AAEA;;AAEG;AACH,SAAS,WAAW,CAAC;EAAE;AAAK,CAAyB,EAAA;EACnD,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAC,OAAO,CAAC,IAAI,IAAG;IACzC,MAAM,KAAK,GAAG,KAAK,CAAC,MAAM,CAAC,IAAI,CAAC,IAAI,CAAA,CAAE;IAEtC,MAAM,UAAU,GAAG,KAAK,CAAC,UAAU,CAAC,IAAI,CAAC,IAAI,CAAA,CAAE;IAC/C,MAAM,OAAO,GAAG,KAAK,CAAC,QAAQ,CAAC,IAAI,CAAC;IAEpC;IACA,IAAI,CAAC,aAAa,CAAC,OAAO,CAAC,IAAI,CAAC,WAAW,CAAC,OAAO,CAAC,EAAE;MACpD;IACD;IAED;IACA;IACA;IACA,MAAM,CAAC,MAAM,CAAC,OAAO,CAAC,KAAK,EAAE,KAAK,CAAC;IAEnC,MAAM,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC,OAAO,CAAC,IAAI,IAAG;MACrC,MAAM,KAAK,GAAG,UAAU,CAAC,IAAI,CAAC;MAC9B,IAAI,KAAK,KAAK,KAAK,EAAE;QACnB,OAAO,CAAC,eAAe,CAAC,IAAI,CAAC;OAC9B,MAAM;QACL,OAAO,CAAC,YAAY,CAAC,IAAI,EAAE,KAAK,KAAK,IAAI,GAAG,EAAE,GAAG,KAAK,CAAC;MACxD;IACH,CAAC,CAAC;EACJ,CAAC,CAAC;AACJ;AAEA;;AAEG;AACH,SAAS,MAAM,CAAC;EAAE;AAAK,CAAyB,EAAA;EAC9C,MAAM,aAAa,GAAG;IACpB,MAAM,EAAE;MACN,QAAQ,EAAE,KAAK,CAAC,OAAO,CAAC,QAAQ;MAChC,IAAI,EAAE,GAAG;MACT,GAAG,EAAE,GAAG;MACR,MAAM,EAAE;KACT;IACD,KAAK,EAAE;MACL,QAAQ,EAAE;KACX;IACD,SAAS,EAAE,CAAA;GACZ;EAED,MAAM,CAAC,MAAM,CAAC,KAAK,CAAC,QAAQ,CAAC,MAAM,CAAC,KAAK,EAAE,aAAa,CAAC,MAAM,CAAC;EAEhE,IAAI,KAAK,CAAC,QAAQ,CAAC,KAAK,EAAE;IACxB,MAAM,CAAC,MAAM,CAAC,KAAK,CAAC,QAAQ,CAAC,KAAK,CAAC,KAAK,EAAE,aAAa,CAAC,KAAK,CAAC;EAC/D;EAED,OAAO,MAAK;IACV,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAC,OAAO,CAAC,IAAI,IAAG;MACzC,MAAM,OAAO,GAAG,KAAK,CAAC,QAAQ,CAAC,IAAI,CAAC;MACpC,MAAM,UAAU,GAAG,KAAK,CAAC,UAAU,CAAC,IAAI,CAAC,IAAI,CAAA,CAAE;MAE/C,MAAM,eAAe,GAAG,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,cAAc,CAAC,IAAI,CAAC,GAAG,KAAK,CAAC,MAAM,CAAC,IAAI,CAAC,GAAG,aAAa,CAAC,IAAI,CAAC,CAAC;MAEjH;MACA,MAAM,KAAK,GAAG,eAAe,CAAC,MAAM,CAAC,CAAC,KAAK,EAAE,QAAQ,KAAI;QACvD,KAAK,CAAC,QAAQ,CAAC,GAAG,EAAE;QACpB,OAAO,KAAK;MACd,CAAC,EAAE,CAAA,CAAE,CAAC;MAEN;MACA,IAAI,CAAC,aAAa,CAAC,OAAO,CAAC,IAAI,CAAC,WAAW,CAAC,OAAO,CAAC,EAAE;QACpD;MACD;MAED;MACA;MACA;MACA,MAAM,CAAC,MAAM,CAAC,OAAO,CAAC,KAAK,EAAE,KAAK,CAAC;MAEnC,MAAM,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC,OAAO,CAAC,SAAS,IAAG;QAC1C,OAAO,CAAC,eAAe,CAAC,SAAS,CAAC;MACpC,CAAC,CAAC;IACJ,CAAC,CAAC;EACJ,CAAC;AACH;AAIA,eAAe;EACb,IAAI,EAAE,aAAa;EACnB,OAAO,EAAE,IAAI;EACb,KAAK,EAAE,OAAO;EACd,EAAE,EAAE,WAAW;EACf,MAAM;EACN,QAAQ,EAAE,CAAC,eAAe;CACJ","sourceRoot":"","sourcesContent":["import getNodeName from '../dom-utils/getNodeName';\nimport { isHTMLElement } from '../dom-utils/instanceOf';\n// This modifier takes the styles prepared by the `computeStyles` modifier\n// and applies them to the HTMLElements such as popper and arrow\n/**\n *\n */\nfunction applyStyles({ state }) {\n    Object.keys(state.elements).forEach(name => {\n        const style = state.styles[name] || {};\n        const attributes = state.attributes[name] || {};\n        const element = state.elements[name];\n        // arrow is optional + virtual elements\n        if (!isHTMLElement(element) || !getNodeName(element)) {\n            return;\n        }\n        // Flow doesn't support to extend this property, but it's the most\n        // effective way to apply styles to an HTMLElement\n        // $FlowFixMe\n        Object.assign(element.style, style);\n        Object.keys(attributes).forEach(name => {\n            const value = attributes[name];\n            if (value === false) {\n                element.removeAttribute(name);\n            }\n            else {\n                element.setAttribute(name, value === true ? '' : value);\n            }\n        });\n    });\n}\n/**\n *\n */\nfunction effect({ state }) {\n    const initialStyles = {\n        popper: {\n            position: state.options.strategy,\n            left: '0',\n            top: '0',\n            margin: '0'\n        },\n        arrow: {\n            position: 'absolute'\n        },\n        reference: {}\n    };\n    Object.assign(state.elements.popper.style, initialStyles.popper);\n    if (state.elements.arrow) {\n        Object.assign(state.elements.arrow.style, initialStyles.arrow);\n    }\n    return () => {\n        Object.keys(state.elements).forEach(name => {\n            const element = state.elements[name];\n            const attributes = state.attributes[name] || {};\n            const styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]);\n            // Set all values to an empty string to unset them\n            const style = styleProperties.reduce((style, property) => {\n                style[property] = '';\n                return style;\n            }, {});\n            // arrow is optional + virtual elements\n            if (!isHTMLElement(element) || !getNodeName(element)) {\n                return;\n            }\n            // Flow doesn't support to extend this property, but it's the most\n            // effective way to apply styles to an HTMLElement\n            // $FlowFixMe\n            Object.assign(element.style, style);\n            Object.keys(attributes).forEach(attribute => {\n                element.removeAttribute(attribute);\n            });\n        });\n    };\n}\nexport default {\n    name: 'applyStyles',\n    enabled: true,\n    phase: 'write',\n    fn: applyStyles,\n    effect,\n    requires: ['computeStyles']\n};\n//# sourceMappingURL=applyStyles.js.map"]},"metadata":{},"sourceType":"module"}