{"ast":null,"code":"import * as React from 'react';\nimport { canUseDOM } from './util';\n/**\n * This function is a helper for handling basic arrow keyboard interactions. If a component already has its own key handler and event start up/tear down, this function may be easier to integrate in over the full component.\n *\n * @param {event} event Event triggered by the keyboard\n * @param {element[]} navigableElements Valid traversable elements of the container\n * @param {function} isActiveElement Callback to determine if a given element from the navigable elements array is the active element of the page\n * @param {function} getFocusableElement Callback returning the focusable element of a given element from the navigable elements array\n * @param {string[]} validSiblingTags Valid sibling tags that horizontal arrow handling will focus\n * @param {boolean} noVerticalArrowHandling Flag indicating that the included vertical arrow key handling should be ignored\n * @param {boolean} noHorizontalArrowHandling Flag indicating that the included horizontal arrow key handling should be ignored\n * @param {boolean} updateTabIndex Flag indicating that the tabIndex of the currently focused element and next focused element should be updated, in the case of using a roving tabIndex\n * @param {boolean} onlyTraverseSiblings Flag indicating that next focusable element of a horizontal movement will be this element's sibling\n */\nexport const handleArrows = (event, navigableElements, isActiveElement = element => document.activeElement.contains(element), getFocusableElement = element => element, validSiblingTags = ['A', 'BUTTON', 'INPUT'], noVerticalArrowHandling = false, noHorizontalArrowHandling = false, updateTabIndex = true, onlyTraverseSiblings = true) => {\n  const activeElement = document.activeElement;\n  const key = event.key;\n  let moveTarget = null;\n  // Handle vertical arrow keys. If noVerticalArrowHandling is passed, skip this block\n  if (!noVerticalArrowHandling) {\n    if (['ArrowUp', 'ArrowDown'].includes(key)) {\n      event.preventDefault();\n      event.stopImmediatePropagation(); // For menus in menus\n      // Traverse navigableElements to find the element which is currently active\n      let currentIndex = -1;\n      // while (currentIndex === -1) {\n      navigableElements.forEach((element, index) => {\n        if (isActiveElement(element)) {\n          // Once found, move up or down the array by 1. Determined by the vertical arrow key direction\n          let increment = 0;\n          // keep increasing the increment until you've tried the whole navigableElement\n          while (!moveTarget && increment < navigableElements.length && increment * -1 < navigableElements.length) {\n            key === 'ArrowUp' ? increment-- : increment++;\n            currentIndex = index + increment;\n            if (currentIndex >= navigableElements.length) {\n              currentIndex = 0;\n            }\n            if (currentIndex < 0) {\n              currentIndex = navigableElements.length - 1;\n            }\n            // Set the next target element (undefined if none found)\n            moveTarget = getFocusableElement(navigableElements[currentIndex]);\n          }\n        }\n      });\n      // }\n    }\n  }\n  // Handle horizontal arrow keys. If noHorizontalArrowHandling is passed, skip this block\n  if (!noHorizontalArrowHandling) {\n    if (['ArrowLeft', 'ArrowRight'].includes(key)) {\n      event.preventDefault();\n      event.stopImmediatePropagation(); // For menus in menus\n      let currentIndex = -1;\n      navigableElements.forEach((element, index) => {\n        if (isActiveElement(element)) {\n          const activeRow = navigableElements[index].querySelectorAll(validSiblingTags.join(',')); // all focusable elements in my row\n          if (!activeRow.length || onlyTraverseSiblings) {\n            let nextSibling = activeElement;\n            // While a sibling exists, check each sibling to determine if it should be focussed\n            while (nextSibling) {\n              // Set the next checked sibling, determined by the horizontal arrow key direction\n              nextSibling = key === 'ArrowLeft' ? nextSibling.previousElementSibling : nextSibling.nextElementSibling;\n              if (nextSibling) {\n                if (validSiblingTags.includes(nextSibling.tagName)) {\n                  // If the sibling's tag is included in validSiblingTags, set the next target element and break the loop\n                  moveTarget = nextSibling;\n                  break;\n                }\n                // If the sibling's tag is not valid, skip to the next sibling if possible\n              }\n            }\n          } else {\n            activeRow.forEach((focusableElement, index) => {\n              if (event.target === focusableElement) {\n                // Once found, move up or down the array by 1. Determined by the vertical arrow key direction\n                const increment = key === 'ArrowLeft' ? -1 : 1;\n                currentIndex = index + increment;\n                if (currentIndex >= activeRow.length) {\n                  currentIndex = 0;\n                }\n                if (currentIndex < 0) {\n                  currentIndex = activeRow.length - 1;\n                }\n                // Set the next target element\n                moveTarget = activeRow[currentIndex];\n              }\n            });\n          }\n        }\n      });\n    }\n  }\n  if (moveTarget) {\n    // If updateTabIndex is true, set the previously focussed element's tabIndex to -1 and the next focussed element's tabIndex to 0\n    // This updates the tabIndex for a roving tabIndex\n    if (updateTabIndex) {\n      activeElement.tabIndex = -1;\n      moveTarget.tabIndex = 0;\n    }\n    // If a move target has been set by either arrow handler, focus that target\n    moveTarget.focus();\n  }\n};\n/**\n * This function is a helper for setting the initial tabIndexes in a roving tabIndex\n *\n * @param {HTMLElement[]} options Array of elements which should have a tabIndex of -1, except for the first element which will have a tabIndex of 0\n */\nexport const setTabIndex = options => {\n  if (options && options.length > 0) {\n    // Iterate the options and set the tabIndex to -1 on every option\n    options.forEach(option => {\n      option.tabIndex = -1;\n    });\n    // Manually set the tabIndex of the first option to 0\n    options[0].tabIndex = 0;\n  }\n};\nexport class KeyboardHandler extends React.Component {\n  constructor() {\n    super(...arguments);\n    this.keyHandler = event => {\n      const {\n        isEventFromContainer\n      } = this.props;\n      // If the passed keyboard event is not from the container, ignore the event by returning\n      if (isEventFromContainer ? !isEventFromContainer(event) : !this._isEventFromContainer(event)) {\n        return;\n      }\n      const {\n        isActiveElement,\n        getFocusableElement,\n        noVerticalArrowHandling,\n        noHorizontalArrowHandling,\n        noEnterHandling,\n        noSpaceHandling,\n        updateTabIndex,\n        validSiblingTags,\n        additionalKeyHandler,\n        createNavigableElements,\n        onlyTraverseSiblings\n      } = this.props;\n      // Pass the event off to be handled by any custom handler\n      additionalKeyHandler && additionalKeyHandler(event);\n      // Initalize navigableElements from the createNavigableElements callback\n      const navigableElements = createNavigableElements();\n      if (!navigableElements) {\n        // eslint-disable-next-line no-console\n        console.warn('No navigable elements have been passed to the KeyboardHandler. Keyboard navigation provided by this component will be ignored.');\n        return;\n      }\n      const key = event.key;\n      // Handle enter key. If noEnterHandling is passed, skip this block\n      if (!noEnterHandling) {\n        if (key === 'Enter') {\n          event.preventDefault();\n          event.stopImmediatePropagation(); // For menus in menus\n          document.activeElement.click();\n        }\n      }\n      // Handle space key. If noSpaceHandling is passed, skip this block\n      if (!noSpaceHandling) {\n        if (key === ' ') {\n          event.preventDefault();\n          event.stopImmediatePropagation(); // For menus in menus\n          document.activeElement.click();\n        }\n      }\n      // Inject helper handler for arrow navigation\n      handleArrows(event, navigableElements, isActiveElement, getFocusableElement, validSiblingTags, noVerticalArrowHandling, noHorizontalArrowHandling, updateTabIndex, onlyTraverseSiblings);\n    };\n    this._isEventFromContainer = event => {\n      const {\n        containerRef\n      } = this.props;\n      return containerRef.current && containerRef.current.contains(event.target);\n    };\n  }\n  componentDidMount() {\n    if (canUseDOM) {\n      window.addEventListener('keydown', this.keyHandler);\n    }\n  }\n  componentWillUnmount() {\n    if (canUseDOM) {\n      window.removeEventListener('keydown', this.keyHandler);\n    }\n  }\n  render() {\n    return null;\n  }\n}\nKeyboardHandler.displayName = 'KeyboardHandler';\nKeyboardHandler.defaultProps = {\n  containerRef: null,\n  createNavigableElements: () => null,\n  isActiveElement: navigableElement => document.activeElement === navigableElement,\n  getFocusableElement: navigableElement => navigableElement,\n  validSiblingTags: ['BUTTON', 'A'],\n  onlyTraverseSiblings: true,\n  updateTabIndex: true,\n  noHorizontalArrowHandling: false,\n  noVerticalArrowHandling: false,\n  noEnterHandling: false,\n  noSpaceHandling: false\n};","map":{"version":3,"sources":["../../../src/helpers/KeyboardHandler.tsx"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import * as React from 'react';\nimport { canUseDOM } from './util';\n/**\n * This function is a helper for handling basic arrow keyboard interactions. If a component already has its own key handler and event start up/tear down, this function may be easier to integrate in over the full component.\n *\n * @param {event} event Event triggered by the keyboard\n * @param {element[]} navigableElements Valid traversable elements of the container\n * @param {function} isActiveElement Callback to determine if a given element from the navigable elements array is the active element of the page\n * @param {function} getFocusableElement Callback returning the focusable element of a given element from the navigable elements array\n * @param {string[]} validSiblingTags Valid sibling tags that horizontal arrow handling will focus\n * @param {boolean} noVerticalArrowHandling Flag indicating that the included vertical arrow key handling should be ignored\n * @param {boolean} noHorizontalArrowHandling Flag indicating that the included horizontal arrow key handling should be ignored\n * @param {boolean} updateTabIndex Flag indicating that the tabIndex of the currently focused element and next focused element should be updated, in the case of using a roving tabIndex\n * @param {boolean} onlyTraverseSiblings Flag indicating that next focusable element of a horizontal movement will be this element's sibling\n */\nexport const handleArrows = (event, navigableElements, isActiveElement = element => document.activeElement.contains(element), getFocusableElement = element => element, validSiblingTags = ['A', 'BUTTON', 'INPUT'], noVerticalArrowHandling = false, noHorizontalArrowHandling = false, updateTabIndex = true, onlyTraverseSiblings = true) => {\n    const activeElement = document.activeElement;\n    const key = event.key;\n    let moveTarget = null;\n    // Handle vertical arrow keys. If noVerticalArrowHandling is passed, skip this block\n    if (!noVerticalArrowHandling) {\n        if (['ArrowUp', 'ArrowDown'].includes(key)) {\n            event.preventDefault();\n            event.stopImmediatePropagation(); // For menus in menus\n            // Traverse navigableElements to find the element which is currently active\n            let currentIndex = -1;\n            // while (currentIndex === -1) {\n            navigableElements.forEach((element, index) => {\n                if (isActiveElement(element)) {\n                    // Once found, move up or down the array by 1. Determined by the vertical arrow key direction\n                    let increment = 0;\n                    // keep increasing the increment until you've tried the whole navigableElement\n                    while (!moveTarget && increment < navigableElements.length && increment * -1 < navigableElements.length) {\n                        key === 'ArrowUp' ? increment-- : increment++;\n                        currentIndex = index + increment;\n                        if (currentIndex >= navigableElements.length) {\n                            currentIndex = 0;\n                        }\n                        if (currentIndex < 0) {\n                            currentIndex = navigableElements.length - 1;\n                        }\n                        // Set the next target element (undefined if none found)\n                        moveTarget = getFocusableElement(navigableElements[currentIndex]);\n                    }\n                }\n            });\n            // }\n        }\n    }\n    // Handle horizontal arrow keys. If noHorizontalArrowHandling is passed, skip this block\n    if (!noHorizontalArrowHandling) {\n        if (['ArrowLeft', 'ArrowRight'].includes(key)) {\n            event.preventDefault();\n            event.stopImmediatePropagation(); // For menus in menus\n            let currentIndex = -1;\n            navigableElements.forEach((element, index) => {\n                if (isActiveElement(element)) {\n                    const activeRow = navigableElements[index].querySelectorAll(validSiblingTags.join(',')); // all focusable elements in my row\n                    if (!activeRow.length || onlyTraverseSiblings) {\n                        let nextSibling = activeElement;\n                        // While a sibling exists, check each sibling to determine if it should be focussed\n                        while (nextSibling) {\n                            // Set the next checked sibling, determined by the horizontal arrow key direction\n                            nextSibling = key === 'ArrowLeft' ? nextSibling.previousElementSibling : nextSibling.nextElementSibling;\n                            if (nextSibling) {\n                                if (validSiblingTags.includes(nextSibling.tagName)) {\n                                    // If the sibling's tag is included in validSiblingTags, set the next target element and break the loop\n                                    moveTarget = nextSibling;\n                                    break;\n                                }\n                                // If the sibling's tag is not valid, skip to the next sibling if possible\n                            }\n                        }\n                    }\n                    else {\n                        activeRow.forEach((focusableElement, index) => {\n                            if (event.target === focusableElement) {\n                                // Once found, move up or down the array by 1. Determined by the vertical arrow key direction\n                                const increment = key === 'ArrowLeft' ? -1 : 1;\n                                currentIndex = index + increment;\n                                if (currentIndex >= activeRow.length) {\n                                    currentIndex = 0;\n                                }\n                                if (currentIndex < 0) {\n                                    currentIndex = activeRow.length - 1;\n                                }\n                                // Set the next target element\n                                moveTarget = activeRow[currentIndex];\n                            }\n                        });\n                    }\n                }\n            });\n        }\n    }\n    if (moveTarget) {\n        // If updateTabIndex is true, set the previously focussed element's tabIndex to -1 and the next focussed element's tabIndex to 0\n        // This updates the tabIndex for a roving tabIndex\n        if (updateTabIndex) {\n            activeElement.tabIndex = -1;\n            moveTarget.tabIndex = 0;\n        }\n        // If a move target has been set by either arrow handler, focus that target\n        moveTarget.focus();\n    }\n};\n/**\n * This function is a helper for setting the initial tabIndexes in a roving tabIndex\n *\n * @param {HTMLElement[]} options Array of elements which should have a tabIndex of -1, except for the first element which will have a tabIndex of 0\n */\nexport const setTabIndex = (options) => {\n    if (options && options.length > 0) {\n        // Iterate the options and set the tabIndex to -1 on every option\n        options.forEach((option) => {\n            option.tabIndex = -1;\n        });\n        // Manually set the tabIndex of the first option to 0\n        options[0].tabIndex = 0;\n    }\n};\nexport class KeyboardHandler extends React.Component {\n    constructor() {\n        super(...arguments);\n        this.keyHandler = (event) => {\n            const { isEventFromContainer } = this.props;\n            // If the passed keyboard event is not from the container, ignore the event by returning\n            if (isEventFromContainer ? !isEventFromContainer(event) : !this._isEventFromContainer(event)) {\n                return;\n            }\n            const { isActiveElement, getFocusableElement, noVerticalArrowHandling, noHorizontalArrowHandling, noEnterHandling, noSpaceHandling, updateTabIndex, validSiblingTags, additionalKeyHandler, createNavigableElements, onlyTraverseSiblings } = this.props;\n            // Pass the event off to be handled by any custom handler\n            additionalKeyHandler && additionalKeyHandler(event);\n            // Initalize navigableElements from the createNavigableElements callback\n            const navigableElements = createNavigableElements();\n            if (!navigableElements) {\n                // eslint-disable-next-line no-console\n                console.warn('No navigable elements have been passed to the KeyboardHandler. Keyboard navigation provided by this component will be ignored.');\n                return;\n            }\n            const key = event.key;\n            // Handle enter key. If noEnterHandling is passed, skip this block\n            if (!noEnterHandling) {\n                if (key === 'Enter') {\n                    event.preventDefault();\n                    event.stopImmediatePropagation(); // For menus in menus\n                    document.activeElement.click();\n                }\n            }\n            // Handle space key. If noSpaceHandling is passed, skip this block\n            if (!noSpaceHandling) {\n                if (key === ' ') {\n                    event.preventDefault();\n                    event.stopImmediatePropagation(); // For menus in menus\n                    document.activeElement.click();\n                }\n            }\n            // Inject helper handler for arrow navigation\n            handleArrows(event, navigableElements, isActiveElement, getFocusableElement, validSiblingTags, noVerticalArrowHandling, noHorizontalArrowHandling, updateTabIndex, onlyTraverseSiblings);\n        };\n        this._isEventFromContainer = (event) => {\n            const { containerRef } = this.props;\n            return containerRef.current && containerRef.current.contains(event.target);\n        };\n    }\n    componentDidMount() {\n        if (canUseDOM) {\n            window.addEventListener('keydown', this.keyHandler);\n        }\n    }\n    componentWillUnmount() {\n        if (canUseDOM) {\n            window.removeEventListener('keydown', this.keyHandler);\n        }\n    }\n    render() {\n        return null;\n    }\n}\nKeyboardHandler.displayName = 'KeyboardHandler';\nKeyboardHandler.defaultProps = {\n    containerRef: null,\n    createNavigableElements: () => null,\n    isActiveElement: (navigableElement) => document.activeElement === navigableElement,\n    getFocusableElement: (navigableElement) => navigableElement,\n    validSiblingTags: ['BUTTON', 'A'],\n    onlyTraverseSiblings: true,\n    updateTabIndex: true,\n    noHorizontalArrowHandling: false,\n    noVerticalArrowHandling: false,\n    noEnterHandling: false,\n    noSpaceHandling: false\n};\n//# sourceMappingURL=KeyboardHandler.js.map"]},"metadata":{},"sourceType":"module"}