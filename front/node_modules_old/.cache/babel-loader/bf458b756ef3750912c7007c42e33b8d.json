{"ast":null,"code":"import getBoundingClientRect from '../dom-utils/getBoundingClientRect';\nimport getClippingRect from '../dom-utils/getClippingRect';\nimport getDocumentElement from '../dom-utils/getDocumentElement';\nimport computeOffsets from './computeOffsets';\nimport rectToClientRect from './rectToClientRect';\nimport { clippingParents, reference, popper, bottom, top, right, basePlacements, viewport } from '../enums';\nimport { isElement } from '../dom-utils/instanceOf';\nimport mergePaddingObject from './mergePaddingObject';\nimport expandToHashMap from './expandToHashMap';\n/**\n * @param state\n * @param options\n */\nexport default function detectOverflow(state, options = {}) {\n  const {\n    placement = state.placement,\n    boundary = clippingParents,\n    rootBoundary = viewport,\n    elementContext = popper,\n    altBoundary = false,\n    padding = 0\n  } = options;\n  const paddingObject = mergePaddingObject(typeof padding !== 'number' ? padding : expandToHashMap(padding, basePlacements));\n  const altContext = elementContext === popper ? reference : popper;\n  const referenceElement = state.elements.reference;\n  const popperRect = state.rects.popper;\n  const element = state.elements[altBoundary ? altContext : elementContext];\n  const clippingClientRect = getClippingRect(isElement(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary);\n  const referenceClientRect = getBoundingClientRect(referenceElement);\n  const popperOffsets = computeOffsets({\n    reference: referenceClientRect,\n    element: popperRect,\n    strategy: 'absolute',\n    placement\n  });\n  const popperClientRect = rectToClientRect(Object.assign(Object.assign({}, popperRect), popperOffsets));\n  const elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect;\n  // positive = overflowing the clipping rect\n  // 0 or negative = within the clipping rect\n  const overflowOffsets = {\n    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,\n    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,\n    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,\n    right: elementClientRect.right - clippingClientRect.right + paddingObject.right\n  };\n  const offsetData = state.modifiersData.offset;\n  // Offsets can be applied only to the popper element\n  if (elementContext === popper && offsetData) {\n    const offset = offsetData[placement];\n    Object.keys(overflowOffsets).forEach(key => {\n      const multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;\n      const axis = [top, bottom].indexOf(key) >= 0 ? 'y' : 'x';\n      overflowOffsets[key] += offset[axis] * multiply;\n    });\n  }\n  return overflowOffsets;\n}","map":{"version":3,"sources":["../../../../../../../src/helpers/Popper/thirdparty/popper-core/utils/detectOverflow.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import getBoundingClientRect from '../dom-utils/getBoundingClientRect';\nimport getClippingRect from '../dom-utils/getClippingRect';\nimport getDocumentElement from '../dom-utils/getDocumentElement';\nimport computeOffsets from './computeOffsets';\nimport rectToClientRect from './rectToClientRect';\nimport { clippingParents, reference, popper, bottom, top, right, basePlacements, viewport } from '../enums';\nimport { isElement } from '../dom-utils/instanceOf';\nimport mergePaddingObject from './mergePaddingObject';\nimport expandToHashMap from './expandToHashMap';\n/**\n * @param state\n * @param options\n */\nexport default function detectOverflow(state, options = {}) {\n    const { placement = state.placement, boundary = clippingParents, rootBoundary = viewport, elementContext = popper, altBoundary = false, padding = 0 } = options;\n    const paddingObject = mergePaddingObject(typeof padding !== 'number' ? padding : expandToHashMap(padding, basePlacements));\n    const altContext = elementContext === popper ? reference : popper;\n    const referenceElement = state.elements.reference;\n    const popperRect = state.rects.popper;\n    const element = state.elements[altBoundary ? altContext : elementContext];\n    const clippingClientRect = getClippingRect(isElement(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary);\n    const referenceClientRect = getBoundingClientRect(referenceElement);\n    const popperOffsets = computeOffsets({\n        reference: referenceClientRect,\n        element: popperRect,\n        strategy: 'absolute',\n        placement\n    });\n    const popperClientRect = rectToClientRect(Object.assign(Object.assign({}, popperRect), popperOffsets));\n    const elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect;\n    // positive = overflowing the clipping rect\n    // 0 or negative = within the clipping rect\n    const overflowOffsets = {\n        top: clippingClientRect.top - elementClientRect.top + paddingObject.top,\n        bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,\n        left: clippingClientRect.left - elementClientRect.left + paddingObject.left,\n        right: elementClientRect.right - clippingClientRect.right + paddingObject.right\n    };\n    const offsetData = state.modifiersData.offset;\n    // Offsets can be applied only to the popper element\n    if (elementContext === popper && offsetData) {\n        const offset = offsetData[placement];\n        Object.keys(overflowOffsets).forEach(key => {\n            const multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;\n            const axis = [top, bottom].indexOf(key) >= 0 ? 'y' : 'x';\n            overflowOffsets[key] += offset[axis] * multiply;\n        });\n    }\n    return overflowOffsets;\n}\n//# sourceMappingURL=detectOverflow.js.map"]},"metadata":{},"sourceType":"module"}