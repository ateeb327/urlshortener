{"ast":null,"code":"export const amSuffix = ' AM';\nexport const pmSuffix = ' PM';\nexport const makeTimeOptions = (stepMinutes, hour12, delimiter, minTime, maxTime, includeSeconds) => {\n  const res = [];\n  const iter = new Date(new Date().setHours(0, 0, 0, 0));\n  const iterDay = iter.getDay();\n  while (iter.getDay() === iterDay) {\n    let hour = iter.getHours();\n    let suffix = amSuffix;\n    if (hour12) {\n      if (hour === 0) {\n        hour = 12; // 12am\n      } else if (hour >= 12) {\n        suffix = pmSuffix;\n      }\n      if (hour > 12) {\n        hour %= 12;\n      }\n    }\n    hour = hour12 ? hour.toString() : hour.toString().padStart(2, '0');\n    const minutes = iter.getMinutes().toString().padStart(2, '0');\n    const timeOption = `${hour}${delimiter}${minutes}${hour12 ? suffix : ''}`;\n    // time option is valid if within min/max constraints\n    if (isWithinMinMax(minTime, maxTime, timeOption, delimiter, includeSeconds)) {\n      res.push(timeOption);\n    }\n    iter.setMinutes(iter.getMinutes() + stepMinutes);\n  }\n  return res;\n};\nexport const parseTime = (time, timeRegex, delimiter, is12Hour, includeSeconds) => {\n  const date = new Date(time);\n  // if default time is a ISO 8601 formatted date string, we parse it to hh:mm(am/pm) format\n  if (!isNaN(date.getDate()) && (time instanceof Date || time.includes('T'))) {\n    const hours = is12Hour ? `${date.getHours() > 12 ? date.getHours() - 12 : date.getHours()}` : `${date.getHours()}`.padStart(2, '0');\n    const minutes = `${date.getMinutes()}`.padStart(2, '0');\n    const seconds = includeSeconds ? `${date.getSeconds()}`.padStart(2, '0') : '';\n    const secondsWithDelimiter = seconds ? `${delimiter}${seconds}` : '';\n    let ampm = '';\n    if (is12Hour && date.getHours() > 11) {\n      ampm = pmSuffix;\n    } else if (is12Hour) {\n      ampm = amSuffix;\n    }\n    return `${hours}${delimiter}${minutes}${secondsWithDelimiter}${ampm}`;\n  } else if (typeof time === 'string') {\n    time = time.trim();\n    if (time !== '' && validateTime(time, timeRegex, delimiter, is12Hour)) {\n      const [, hours, minutes, seconds, suffix = ''] = timeRegex.exec(time);\n      const secondsWithDelimiter = includeSeconds ? `${delimiter}${seconds !== null && seconds !== void 0 ? seconds : '00'}` : '';\n      let ampm = '';\n      // Format AM/PM according to design\n      if (is12Hour) {\n        const uppercaseSuffix = suffix.toUpperCase();\n        if (uppercaseSuffix === amSuffix.toUpperCase().trim()) {\n          ampm = amSuffix;\n        } else if (uppercaseSuffix === pmSuffix.toUpperCase().trim()) {\n          ampm = pmSuffix;\n        } else {\n          // if this 12 hour time is missing am/pm but otherwise valid,\n          // append am/pm depending on time of day\n          ampm = new Date().getHours() > 11 ? pmSuffix : amSuffix;\n        }\n      }\n      return `${hours}${delimiter}${minutes}${secondsWithDelimiter}${ampm}`;\n    }\n  }\n  return time.toString();\n};\nexport const validateTime = (time, timeRegex, delimiter, is12Hour) => {\n  // ISO 8601 format is valid\n  const date = new Date(time);\n  if (!isNaN(date.getDate()) && time.includes('T')) {\n    return true;\n  }\n  // hours only valid if they are [0-23] or [1-12]\n  const hours = parseInt(time.split(delimiter)[0]);\n  const validHours = hours >= (is12Hour ? 1 : 0) && hours <= (is12Hour ? 12 : 23);\n  // minutes verified by timeRegex\n  // empty string is valid\n  return time === '' || timeRegex.test(time) && validHours;\n};\nexport const getHours = (time, timeRegex) => {\n  const parts = time.match(timeRegex);\n  if (parts && parts.length) {\n    if (/pm/i.test(parts[4])) {\n      return parseInt(parts[1]) === 12 ? parseInt(parts[1]) : parseInt(parts[1]) + 12;\n    }\n    if (/am/i.test(parts[4])) {\n      return parseInt(parts[1]) === 12 ? 0 : parseInt(parts[1]);\n    }\n    return parseInt(parts[1]);\n  }\n  return null;\n};\nexport const getMinutes = (time, timeRegex) => {\n  const parts = time.match(timeRegex);\n  return parts && parts.length ? parseInt(parts[2]) : null;\n};\nexport const getSeconds = (time, timeRegex) => {\n  var _a;\n  const seconds = (_a = time.match(timeRegex)) === null || _a === void 0 ? void 0 : _a[3];\n  return seconds ? parseInt(seconds) : null;\n};\nexport const isWithinMinMax = (minTime, maxTime, time, delimiter, includeSeconds) => {\n  // do not throw error if empty string\n  if (time.trim() === '') {\n    return true;\n  }\n  // correctly format as 24hr times (12:30AM => 00:30, 1:15 => 01:15)\n  const min24HourTime = convertTo24Hour(minTime, delimiter, includeSeconds);\n  const selected24HourTime = convertTo24Hour(time, delimiter, includeSeconds);\n  const max24HourTime = convertTo24Hour(maxTime, delimiter, includeSeconds);\n  // simple string comparison for 24hr times\n  return min24HourTime <= selected24HourTime && selected24HourTime <= max24HourTime;\n};\nconst convertTo24Hour = (time, delimiter, includeSeconds) => {\n  const timeReg = new RegExp(`^\\\\s*(\\\\d\\\\d?)${delimiter}([0-5]\\\\d)${delimiter}?([0-5]\\\\d)?\\\\s*([AaPp][Mm])?\\\\s*$`);\n  const regMatches = timeReg.exec(time);\n  if (!regMatches || !regMatches.length) {\n    return;\n  }\n  let hours = regMatches[1].padStart(2, '0');\n  const minutes = regMatches[2];\n  let seconds = regMatches[3] ? `${delimiter}${regMatches[3]}` : '';\n  // When seconds is empty and 'includeSeconds' is enabled, append 0 seconds.\n  if (!seconds && includeSeconds) {\n    seconds = `${delimiter}00`;\n  }\n  const suffix = regMatches[4] || '';\n  if (suffix.toUpperCase() === 'PM' && hours !== '12') {\n    hours = `${parseInt(hours) + 12}`;\n  } else if (suffix.toUpperCase() === 'AM' && hours === '12') {\n    hours = '00';\n  }\n  return `${hours}${delimiter}${minutes}${seconds}`;\n};","map":{"version":3,"sources":["../../../../src/components/TimePicker/TimePickerUtils.tsx"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["export const amSuffix = ' AM';\nexport const pmSuffix = ' PM';\nexport const makeTimeOptions = (stepMinutes, hour12, delimiter, minTime, maxTime, includeSeconds) => {\n    const res = [];\n    const iter = new Date(new Date().setHours(0, 0, 0, 0));\n    const iterDay = iter.getDay();\n    while (iter.getDay() === iterDay) {\n        let hour = iter.getHours();\n        let suffix = amSuffix;\n        if (hour12) {\n            if (hour === 0) {\n                hour = 12; // 12am\n            }\n            else if (hour >= 12) {\n                suffix = pmSuffix;\n            }\n            if (hour > 12) {\n                hour %= 12;\n            }\n        }\n        hour = hour12 ? hour.toString() : hour.toString().padStart(2, '0');\n        const minutes = iter\n            .getMinutes()\n            .toString()\n            .padStart(2, '0');\n        const timeOption = `${hour}${delimiter}${minutes}${hour12 ? suffix : ''}`;\n        // time option is valid if within min/max constraints\n        if (isWithinMinMax(minTime, maxTime, timeOption, delimiter, includeSeconds)) {\n            res.push(timeOption);\n        }\n        iter.setMinutes(iter.getMinutes() + stepMinutes);\n    }\n    return res;\n};\nexport const parseTime = (time, timeRegex, delimiter, is12Hour, includeSeconds) => {\n    const date = new Date(time);\n    // if default time is a ISO 8601 formatted date string, we parse it to hh:mm(am/pm) format\n    if (!isNaN(date.getDate()) && (time instanceof Date || time.includes('T'))) {\n        const hours = is12Hour\n            ? `${date.getHours() > 12 ? date.getHours() - 12 : date.getHours()}`\n            : `${date.getHours()}`.padStart(2, '0');\n        const minutes = `${date.getMinutes()}`.padStart(2, '0');\n        const seconds = includeSeconds ? `${date.getSeconds()}`.padStart(2, '0') : '';\n        const secondsWithDelimiter = seconds ? `${delimiter}${seconds}` : '';\n        let ampm = '';\n        if (is12Hour && date.getHours() > 11) {\n            ampm = pmSuffix;\n        }\n        else if (is12Hour) {\n            ampm = amSuffix;\n        }\n        return `${hours}${delimiter}${minutes}${secondsWithDelimiter}${ampm}`;\n    }\n    else if (typeof time === 'string') {\n        time = time.trim();\n        if (time !== '' && validateTime(time, timeRegex, delimiter, is12Hour)) {\n            const [, hours, minutes, seconds, suffix = ''] = timeRegex.exec(time);\n            const secondsWithDelimiter = includeSeconds ? `${delimiter}${seconds !== null && seconds !== void 0 ? seconds : '00'}` : '';\n            let ampm = '';\n            // Format AM/PM according to design\n            if (is12Hour) {\n                const uppercaseSuffix = suffix.toUpperCase();\n                if (uppercaseSuffix === amSuffix.toUpperCase().trim()) {\n                    ampm = amSuffix;\n                }\n                else if (uppercaseSuffix === pmSuffix.toUpperCase().trim()) {\n                    ampm = pmSuffix;\n                }\n                else {\n                    // if this 12 hour time is missing am/pm but otherwise valid,\n                    // append am/pm depending on time of day\n                    ampm = new Date().getHours() > 11 ? pmSuffix : amSuffix;\n                }\n            }\n            return `${hours}${delimiter}${minutes}${secondsWithDelimiter}${ampm}`;\n        }\n    }\n    return time.toString();\n};\nexport const validateTime = (time, timeRegex, delimiter, is12Hour) => {\n    // ISO 8601 format is valid\n    const date = new Date(time);\n    if (!isNaN(date.getDate()) && time.includes('T')) {\n        return true;\n    }\n    // hours only valid if they are [0-23] or [1-12]\n    const hours = parseInt(time.split(delimiter)[0]);\n    const validHours = hours >= (is12Hour ? 1 : 0) && hours <= (is12Hour ? 12 : 23);\n    // minutes verified by timeRegex\n    // empty string is valid\n    return time === '' || (timeRegex.test(time) && validHours);\n};\nexport const getHours = (time, timeRegex) => {\n    const parts = time.match(timeRegex);\n    if (parts && parts.length) {\n        if (/pm/i.test(parts[4])) {\n            return parseInt(parts[1]) === 12 ? parseInt(parts[1]) : parseInt(parts[1]) + 12;\n        }\n        if (/am/i.test(parts[4])) {\n            return parseInt(parts[1]) === 12 ? 0 : parseInt(parts[1]);\n        }\n        return parseInt(parts[1]);\n    }\n    return null;\n};\nexport const getMinutes = (time, timeRegex) => {\n    const parts = time.match(timeRegex);\n    return parts && parts.length ? parseInt(parts[2]) : null;\n};\nexport const getSeconds = (time, timeRegex) => {\n    var _a;\n    const seconds = (_a = time.match(timeRegex)) === null || _a === void 0 ? void 0 : _a[3];\n    return seconds ? parseInt(seconds) : null;\n};\nexport const isWithinMinMax = (minTime, maxTime, time, delimiter, includeSeconds) => {\n    // do not throw error if empty string\n    if (time.trim() === '') {\n        return true;\n    }\n    // correctly format as 24hr times (12:30AM => 00:30, 1:15 => 01:15)\n    const min24HourTime = convertTo24Hour(minTime, delimiter, includeSeconds);\n    const selected24HourTime = convertTo24Hour(time, delimiter, includeSeconds);\n    const max24HourTime = convertTo24Hour(maxTime, delimiter, includeSeconds);\n    // simple string comparison for 24hr times\n    return min24HourTime <= selected24HourTime && selected24HourTime <= max24HourTime;\n};\nconst convertTo24Hour = (time, delimiter, includeSeconds) => {\n    const timeReg = new RegExp(`^\\\\s*(\\\\d\\\\d?)${delimiter}([0-5]\\\\d)${delimiter}?([0-5]\\\\d)?\\\\s*([AaPp][Mm])?\\\\s*$`);\n    const regMatches = timeReg.exec(time);\n    if (!regMatches || !regMatches.length) {\n        return;\n    }\n    let hours = regMatches[1].padStart(2, '0');\n    const minutes = regMatches[2];\n    let seconds = regMatches[3] ? `${delimiter}${regMatches[3]}` : '';\n    // When seconds is empty and 'includeSeconds' is enabled, append 0 seconds.\n    if (!seconds && includeSeconds) {\n        seconds = `${delimiter}00`;\n    }\n    const suffix = regMatches[4] || '';\n    if (suffix.toUpperCase() === 'PM' && hours !== '12') {\n        hours = `${parseInt(hours) + 12}`;\n    }\n    else if (suffix.toUpperCase() === 'AM' && hours === '12') {\n        hours = '00';\n    }\n    return `${hours}${delimiter}${minutes}${seconds}`;\n};\n//# sourceMappingURL=TimePickerUtils.js.map"]},"metadata":{},"sourceType":"module"}