{"ast":null,"code":"import getVariation from './getVariation';\nimport { variationPlacements, basePlacements, placements as allPlacements } from '../enums';\nimport detectOverflow from './detectOverflow';\nimport getBasePlacement from './getBasePlacement';\n/* :: type OverflowsMap = { [ComputedPlacement]: number }; */\n/* ;; type OverflowsMap = { [key in ComputedPlacement]: number }; */\n/**\n * @param state\n * @param options\n */\nexport default function computeAutoPlacement(state, options = {}) {\n  const {\n    placement,\n    boundary,\n    rootBoundary,\n    padding,\n    flipVariations,\n    allowedAutoPlacements = allPlacements\n  } = options;\n  const variation = getVariation(placement);\n  const placements = variation ? flipVariations ? variationPlacements : variationPlacements.filter(placement => getVariation(placement) === variation) : basePlacements;\n  // $FlowFixMe\n  let allowedPlacements = placements.filter(placement => allowedAutoPlacements.indexOf(placement) >= 0);\n  if (allowedPlacements.length === 0) {\n    allowedPlacements = placements;\n    if (false /* __DEV__*/) {\n      console.error(['Popper: The `allowedAutoPlacements` option did not allow any', 'placements. Ensure the `placement` option matches the variation', 'of the allowed placements.', 'For example, \"auto\" cannot be used to allow \"bottom-start\".', 'Use \"auto-start\" instead.'].join(' '));\n    }\n  }\n  // $FlowFixMe: Flow seems to have problems with two array unions...\n  const overflows = allowedPlacements.reduce((acc, placement) => {\n    acc[placement] = detectOverflow(state, {\n      placement,\n      boundary,\n      rootBoundary,\n      padding\n    })[getBasePlacement(placement)];\n    return acc;\n  }, {});\n  return Object.keys(overflows).sort((a, b) => overflows[a] - overflows[b]);\n}","map":{"version":3,"sources":["../../../../../../../src/helpers/Popper/thirdparty/popper-core/utils/computeAutoPlacement.ts"],"names":[],"mappings":"AAGA,OAAO,YAAY,MAAM,gBAAgB;AACzC,SAAS,mBAAmB,EAAE,cAAc,EAAE,UAAU,IAAI,aAAa,QAAQ,UAAU;AAC3F,OAAO,cAAc,MAAM,kBAAkB;AAC7C,OAAO,gBAAgB,MAAM,oBAAoB;AAWjD;AAEA;AAEA;;;AAGG;AACH,eAAc,SAAU,oBAAoB,CAAC,KAAqB,EAAE,OAAA,GAAmB,CAAA,CAAE,EAAA;EACvF,MAAM;IAAE,SAAS;IAAE,QAAQ;IAAE,YAAY;IAAE,OAAO;IAAE,cAAc;IAAE,qBAAqB,GAAG;EAAa,CAAE,GAAG,OAAO;EAErH,MAAM,SAAS,GAAG,YAAY,CAAC,SAAS,CAAC;EAEzC,MAAM,UAAU,GAAG,SAAS,GACxB,cAAc,GACZ,mBAAmB,GACnB,mBAAmB,CAAC,MAAM,CAAC,SAAS,IAAI,YAAY,CAAC,SAAS,CAAC,KAAK,SAAS,CAAC,GAChF,cAAc;EAElB;EACA,IAAI,iBAAiB,GAAG,UAAU,CAAC,MAAM,CAAC,SAAS,IAAI,qBAAqB,CAAC,OAAO,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC;EAErG,IAAI,iBAAiB,CAAC,MAAM,KAAK,CAAC,EAAE;IAClC,iBAAiB,GAAG,UAAU;IAE9B,IAAI,KAAK,CAAC,cAAc;MACtB,OAAO,CAAC,KAAK,CACX,CACE,8DAA8D,EAC9D,iEAAiE,EACjE,4BAA4B,EAC5B,6DAA6D,EAC7D,2BAA2B,CAC5B,CAAC,IAAI,CAAC,GAAG,CAAC,CACZ;IACF;EACF;EAED;EACA,MAAM,SAAS,GAAiB,iBAAiB,CAAC,MAAM,CAAC,CAAC,GAAG,EAAE,SAAS,KAAI;IAC1E,GAAG,CAAC,SAAS,CAAC,GAAG,cAAc,CAAC,KAAK,EAAE;MACrC,SAAS;MACT,QAAQ;MACR,YAAY;MACZ;KACD,CAAC,CAAC,gBAAgB,CAAC,SAAS,CAAC,CAAC;IAE/B,OAAO,GAAG;EACZ,CAAC,EAAE,CAAA,CAAE,CAAC;EAEN,OAAO,MAAM,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,KAAK,SAAS,CAAC,CAAC,CAAC,GAAG,SAAS,CAAC,CAAC,CAAC,CAAC;AAC3E","sourceRoot":"","sourcesContent":["import getVariation from './getVariation';\nimport { variationPlacements, basePlacements, placements as allPlacements } from '../enums';\nimport detectOverflow from './detectOverflow';\nimport getBasePlacement from './getBasePlacement';\n/* :: type OverflowsMap = { [ComputedPlacement]: number }; */\n/* ;; type OverflowsMap = { [key in ComputedPlacement]: number }; */\n/**\n * @param state\n * @param options\n */\nexport default function computeAutoPlacement(state, options = {}) {\n    const { placement, boundary, rootBoundary, padding, flipVariations, allowedAutoPlacements = allPlacements } = options;\n    const variation = getVariation(placement);\n    const placements = variation\n        ? flipVariations\n            ? variationPlacements\n            : variationPlacements.filter(placement => getVariation(placement) === variation)\n        : basePlacements;\n    // $FlowFixMe\n    let allowedPlacements = placements.filter(placement => allowedAutoPlacements.indexOf(placement) >= 0);\n    if (allowedPlacements.length === 0) {\n        allowedPlacements = placements;\n        if (false /* __DEV__*/) {\n            console.error([\n                'Popper: The `allowedAutoPlacements` option did not allow any',\n                'placements. Ensure the `placement` option matches the variation',\n                'of the allowed placements.',\n                'For example, \"auto\" cannot be used to allow \"bottom-start\".',\n                'Use \"auto-start\" instead.'\n            ].join(' '));\n        }\n    }\n    // $FlowFixMe: Flow seems to have problems with two array unions...\n    const overflows = allowedPlacements.reduce((acc, placement) => {\n        acc[placement] = detectOverflow(state, {\n            placement,\n            boundary,\n            rootBoundary,\n            padding\n        })[getBasePlacement(placement)];\n        return acc;\n    }, {});\n    return Object.keys(overflows).sort((a, b) => overflows[a] - overflows[b]);\n}\n//# sourceMappingURL=computeAutoPlacement.js.map"]},"metadata":{},"sourceType":"module"}