{"ast":null,"code":"import { __rest } from \"tslib\";\nimport * as React from 'react';\nimport { css } from '@patternfly/react-styles';\nimport datePickerStyles from '@patternfly/react-styles/css/components/DatePicker/date-picker';\nimport formStyles from '@patternfly/react-styles/css/components/FormControl/form-control';\nimport menuStyles from '@patternfly/react-styles/css/components/Menu/menu';\nimport { getUniqueId } from '../../helpers';\nimport { Popper } from '../../helpers/Popper/Popper';\nimport { Menu, MenuContent, MenuList, MenuItem } from '../Menu';\nimport { InputGroup } from '../InputGroup';\nimport { TextInput } from '../TextInput';\nimport { KeyTypes } from '../../helpers/constants';\nimport { parseTime, validateTime, makeTimeOptions, amSuffix, pmSuffix, getHours, getMinutes, isWithinMinMax, getSeconds } from './TimePickerUtils';\nexport class TimePicker extends React.Component {\n  constructor(props) {\n    super(props);\n    this.baseComponentRef = React.createRef();\n    this.toggleRef = React.createRef();\n    this.inputRef = React.createRef();\n    this.menuRef = React.createRef();\n    this.onDocClick = event => {\n      var _a, _b, _c, _d;\n      const clickedOnToggle = (_b = (_a = this.toggleRef) === null || _a === void 0 ? void 0 : _a.current) === null || _b === void 0 ? void 0 : _b.contains(event.target);\n      const clickedWithinMenu = (_d = (_c = this.menuRef) === null || _c === void 0 ? void 0 : _c.current) === null || _d === void 0 ? void 0 : _d.contains(event.target);\n      if (this.state.isTimeOptionsOpen && !(clickedOnToggle || clickedWithinMenu)) {\n        this.onToggle(false);\n      }\n    };\n    this.handleGlobalKeys = event => {\n      var _a, _b, _c, _d;\n      const {\n        isTimeOptionsOpen,\n        focusedIndex,\n        scrollIndex\n      } = this.state;\n      // keyboard pressed while focus on toggle\n      if ((_b = (_a = this.inputRef) === null || _a === void 0 ? void 0 : _a.current) === null || _b === void 0 ? void 0 : _b.contains(event.target)) {\n        if (!isTimeOptionsOpen && event.key !== KeyTypes.Tab && event.key !== KeyTypes.Escape) {\n          this.onToggle(true);\n        } else if (isTimeOptionsOpen) {\n          if (event.key === KeyTypes.Escape || event.key === KeyTypes.Tab) {\n            this.onToggle(false);\n          } else if (event.key === KeyTypes.Enter) {\n            if (focusedIndex !== null) {\n              this.focusSelection(focusedIndex);\n              event.stopPropagation();\n            } else {\n              this.onToggle(false);\n            }\n          } else if (event.key === KeyTypes.ArrowDown || event.key === KeyTypes.ArrowUp) {\n            this.focusSelection(scrollIndex);\n            this.updateFocusedIndex(0);\n            event.preventDefault();\n          }\n        }\n        // keyboard pressed while focus on menu item\n      } else if ((_d = (_c = this.menuRef) === null || _c === void 0 ? void 0 : _c.current) === null || _d === void 0 ? void 0 : _d.contains(event.target)) {\n        if (event.key === KeyTypes.ArrowDown) {\n          this.updateFocusedIndex(1);\n          event.preventDefault();\n        } else if (event.key === KeyTypes.ArrowUp) {\n          this.updateFocusedIndex(-1);\n          event.preventDefault();\n        } else if (event.key === KeyTypes.Escape || event.key === KeyTypes.Tab) {\n          this.inputRef.current.focus();\n          this.onToggle(false);\n        }\n      }\n    };\n    this.updateFocusedIndex = increment => {\n      this.setState(prevState => {\n        const maxIndex = this.getOptions().length - 1;\n        let nextIndex = prevState.focusedIndex !== null ? prevState.focusedIndex + increment : prevState.scrollIndex + increment;\n        if (nextIndex < 0) {\n          nextIndex = maxIndex;\n        } else if (nextIndex > maxIndex) {\n          nextIndex = 0;\n        }\n        this.scrollToIndex(nextIndex);\n        return {\n          focusedIndex: nextIndex\n        };\n      });\n    };\n    // fixes issue where menutAppendTo=\"inline\" results in the menu item that should be scrolled to being out of view; this will select the menu item that comes before the intended one, causing that before-item to be placed out of view instead\n    this.getIndexToScroll = index => {\n      if (this.props.menuAppendTo === 'inline') {\n        return index > 0 ? index - 1 : 0;\n      }\n      return index;\n    };\n    this.scrollToIndex = index => {\n      this.getOptions()[index].closest(`.${menuStyles.menuContent}`).scrollTop = this.getOptions()[this.getIndexToScroll(index)].offsetTop;\n    };\n    this.focusSelection = index => {\n      var _a;\n      const indexToFocus = index !== -1 ? index : 0;\n      if ((_a = this.menuRef) === null || _a === void 0 ? void 0 : _a.current) {\n        this.getOptions()[indexToFocus].querySelector(`.${menuStyles.menuItem}`).focus();\n      }\n    };\n    this.scrollToSelection = time => {\n      const {\n        delimiter,\n        is24Hour\n      } = this.props;\n      let splitTime = time.split(this.props.delimiter);\n      let focusedIndex = null;\n      // build out the rest of the time assuming hh:00 if it's a partial time\n      if (splitTime.length < 2) {\n        time = `${time}${delimiter}00`;\n        splitTime = time.split(delimiter);\n        // due to only the input including seconds when includeSeconds=true, we need to build a temporary time here without those seconds so that an exact or close match can be scrolled to within the menu (which does not include seconds in any of the options)\n      } else if (splitTime.length > 2) {\n        time = parseTime(time, this.state.timeRegex, delimiter, !is24Hour, false);\n        splitTime = time.split(delimiter);\n      }\n      // for 12hr variant, autoscroll to pm if it's currently the afternoon, otherwise autoscroll to am\n      if (!is24Hour && splitTime.length > 1 && splitTime[1].length < 2) {\n        const minutes = splitTime[1].length === 0 ? '00' : splitTime[1] + '0';\n        time = `${splitTime[0]}${delimiter}${minutes}${new Date().getHours() > 11 ? pmSuffix : amSuffix}`;\n      } else if (!is24Hour && splitTime.length > 1 && splitTime[1].length === 2 && !time.toUpperCase().includes(amSuffix.toUpperCase().trim()) && !time.toUpperCase().includes(pmSuffix.toUpperCase().trim())) {\n        time = `${time}${new Date().getHours() > 11 ? pmSuffix : amSuffix}`;\n      }\n      let scrollIndex = this.getOptions().findIndex(option => option.textContent === time);\n      // if we found an exact match, scroll to match and return index of match for focus\n      if (scrollIndex !== -1) {\n        this.scrollToIndex(scrollIndex);\n        focusedIndex = scrollIndex;\n      } else if (splitTime.length === 2) {\n        // no exact match, scroll to closest hour but don't return index for focus\n        let amPm = '';\n        if (!is24Hour) {\n          if (splitTime[1].toUpperCase().includes('P')) {\n            amPm = pmSuffix;\n          } else if (splitTime[1].toUpperCase().includes('A')) {\n            amPm = amSuffix;\n          }\n        }\n        time = `${splitTime[0]}${delimiter}00${amPm}`;\n        scrollIndex = this.getOptions().findIndex(option => option.textContent === time);\n        if (scrollIndex !== -1) {\n          this.scrollToIndex(scrollIndex);\n        }\n      }\n      this.setState({\n        focusedIndex,\n        scrollIndex\n      });\n    };\n    this.getRegExp = (includeSeconds = true) => {\n      const {\n        is24Hour,\n        delimiter\n      } = this.props;\n      let baseRegex = `\\\\s*(\\\\d\\\\d?)${delimiter}([0-5]\\\\d)`;\n      if (includeSeconds) {\n        baseRegex += `${delimiter}?([0-5]\\\\d)?`;\n      }\n      return new RegExp(`^${baseRegex}${is24Hour ? '' : '\\\\s*([AaPp][Mm])?'}\\\\s*$`);\n    };\n    this.getOptions = () => {\n      var _a;\n      return ((_a = this.menuRef) === null || _a === void 0 ? void 0 : _a.current) ? Array.from(this.menuRef.current.querySelectorAll(`.${menuStyles.menuListItem}`)) : [];\n    };\n    this.isValidFormat = time => {\n      if (this.props.validateTime) {\n        return this.props.validateTime(time);\n      }\n      const {\n        delimiter,\n        is24Hour,\n        includeSeconds\n      } = this.props;\n      return validateTime(time, this.getRegExp(includeSeconds), delimiter, !is24Hour);\n    };\n    this.isValidTime = time => {\n      const {\n        delimiter,\n        includeSeconds\n      } = this.props;\n      const {\n        minTimeState,\n        maxTimeState\n      } = this.state;\n      return isWithinMinMax(minTimeState, maxTimeState, time, delimiter, includeSeconds);\n    };\n    this.isValid = time => this.isValidFormat(time) && this.isValidTime(time);\n    this.onToggle = isOpen => {\n      // on close, parse and validate input\n      this.setState(prevState => {\n        const {\n          timeRegex,\n          isInvalid,\n          timeState\n        } = prevState;\n        const {\n          delimiter,\n          is24Hour,\n          includeSeconds,\n          onChange\n        } = this.props;\n        const time = parseTime(timeState, timeRegex, delimiter, !is24Hour, includeSeconds);\n        // Call onChange when Enter is pressed in input and timeoption does not exist in menu\n        if (onChange && !isOpen && time !== timeState) {\n          onChange(null, time, getHours(time, timeRegex), getMinutes(time, timeRegex), getSeconds(time, timeRegex), this.isValid(time));\n        }\n        return {\n          isTimeOptionsOpen: isOpen,\n          timeState: time,\n          isInvalid: isOpen ? isInvalid : !this.isValid(time)\n        };\n      });\n      this.props.setIsOpen(isOpen);\n      if (!isOpen) {\n        this.inputRef.current.focus();\n      }\n    };\n    this.onSelect = e => {\n      const {\n        timeRegex,\n        timeState\n      } = this.state;\n      const {\n        delimiter,\n        is24Hour,\n        includeSeconds,\n        setIsOpen\n      } = this.props;\n      const time = parseTime(e.target.textContent, timeRegex, delimiter, !is24Hour, includeSeconds);\n      if (time !== timeState) {\n        this.onInputChange(time, e);\n      }\n      this.inputRef.current.focus();\n      this.setState({\n        isTimeOptionsOpen: false,\n        isInvalid: false\n      });\n      setIsOpen(false);\n    };\n    this.onInputClick = e => {\n      if (!this.state.isTimeOptionsOpen) {\n        this.onToggle(true);\n      }\n      e.stopPropagation();\n    };\n    this.onInputChange = (newTime, event) => {\n      const {\n        onChange\n      } = this.props;\n      const {\n        timeRegex\n      } = this.state;\n      if (onChange) {\n        onChange(event, newTime, getHours(newTime, timeRegex), getMinutes(newTime, timeRegex), getSeconds(newTime, timeRegex), this.isValid(newTime));\n      }\n      this.scrollToSelection(newTime);\n      this.setState({\n        timeState: newTime\n      });\n    };\n    const {\n      is24Hour,\n      delimiter,\n      time,\n      includeSeconds,\n      isOpen\n    } = this.props;\n    let {\n      minTime,\n      maxTime\n    } = this.props;\n    if (minTime === '') {\n      const minSeconds = includeSeconds ? `${delimiter}00` : '';\n      minTime = is24Hour ? `00${delimiter}00${minSeconds}` : `12${delimiter}00${minSeconds} AM`;\n    }\n    if (maxTime === '') {\n      const maxSeconds = includeSeconds ? `${delimiter}59` : '';\n      maxTime = is24Hour ? `23${delimiter}59${maxSeconds}` : `11${delimiter}59${maxSeconds} PM`;\n    }\n    const timeRegex = this.getRegExp();\n    this.state = {\n      isInvalid: false,\n      isTimeOptionsOpen: isOpen,\n      timeState: parseTime(time, timeRegex, delimiter, !is24Hour, includeSeconds),\n      focusedIndex: null,\n      scrollIndex: 0,\n      timeRegex,\n      minTimeState: parseTime(minTime, timeRegex, delimiter, !is24Hour, includeSeconds),\n      maxTimeState: parseTime(maxTime, timeRegex, delimiter, !is24Hour, includeSeconds)\n    };\n  }\n  componentDidMount() {\n    document.addEventListener('mousedown', this.onDocClick);\n    document.addEventListener('touchstart', this.onDocClick);\n    document.addEventListener('keydown', this.handleGlobalKeys);\n    this.setState({\n      isInvalid: !this.isValid(this.state.timeState)\n    });\n  }\n  componentWillUnmount() {\n    document.removeEventListener('mousedown', this.onDocClick);\n    document.removeEventListener('touchstart', this.onDocClick);\n    document.removeEventListener('keydown', this.handleGlobalKeys);\n  }\n  componentDidUpdate(prevProps, prevState) {\n    const {\n      timeState,\n      isTimeOptionsOpen,\n      isInvalid,\n      timeRegex\n    } = this.state;\n    const {\n      time,\n      is24Hour,\n      delimiter,\n      includeSeconds,\n      isOpen,\n      minTime,\n      maxTime\n    } = this.props;\n    if (prevProps.isOpen !== isOpen) {\n      this.onToggle(isOpen);\n    }\n    if (isTimeOptionsOpen && !prevState.isTimeOptionsOpen && timeState && !isInvalid) {\n      this.scrollToSelection(timeState);\n    }\n    if (delimiter !== prevProps.delimiter) {\n      this.setState({\n        timeRegex: this.getRegExp()\n      });\n    }\n    if (time !== '' && time !== prevProps.time) {\n      const parsedTime = parseTime(time, timeRegex, delimiter, !is24Hour, includeSeconds);\n      this.setState({\n        timeState: parsedTime,\n        isInvalid: !this.isValid(parsedTime)\n      });\n    }\n    if (minTime !== '' && minTime !== prevProps.minTime) {\n      this.setState({\n        minTimeState: parseTime(minTime, timeRegex, delimiter, !is24Hour, includeSeconds)\n      });\n    }\n    if (maxTime !== '' && maxTime !== prevProps.maxTime) {\n      this.setState({\n        maxTimeState: parseTime(maxTime, timeRegex, delimiter, !is24Hour, includeSeconds)\n      });\n    }\n  }\n  render() {\n    const _a = this.props,\n      {\n        'aria-label': ariaLabel,\n        isDisabled,\n        className,\n        placeholder,\n        id,\n        menuAppendTo,\n        is24Hour,\n        invalidFormatErrorMessage,\n        invalidMinMaxErrorMessage,\n        stepMinutes,\n        width,\n        delimiter,\n        inputProps,\n        /* eslint-disable @typescript-eslint/no-unused-vars */\n        onChange,\n        /* eslint-disable @typescript-eslint/no-unused-vars */\n        setIsOpen,\n        /* eslint-disable @typescript-eslint/no-unused-vars */\n        isOpen,\n        time,\n        validateTime,\n        minTime,\n        maxTime,\n        includeSeconds,\n        /* eslint-enable @typescript-eslint/no-unused-vars */\n        removeFindDomNode,\n        zIndex\n      } = _a,\n      props = __rest(_a, ['aria-label', \"isDisabled\", \"className\", \"placeholder\", \"id\", \"menuAppendTo\", \"is24Hour\", \"invalidFormatErrorMessage\", \"invalidMinMaxErrorMessage\", \"stepMinutes\", \"width\", \"delimiter\", \"inputProps\", \"onChange\", \"setIsOpen\", \"isOpen\", \"time\", \"validateTime\", \"minTime\", \"maxTime\", \"includeSeconds\", \"removeFindDomNode\", \"zIndex\"]);\n    const {\n      timeState,\n      isTimeOptionsOpen,\n      isInvalid,\n      minTimeState,\n      maxTimeState\n    } = this.state;\n    const style = {\n      '--pf-c-date-picker__input--c-form-control--Width': width\n    };\n    const options = makeTimeOptions(stepMinutes, !is24Hour, delimiter, minTimeState, maxTimeState, includeSeconds);\n    const isValidFormat = this.isValidFormat(timeState);\n    const randomId = id || getUniqueId('time-picker');\n    const getParentElement = () => {\n      if (this.baseComponentRef && this.baseComponentRef.current) {\n        return this.baseComponentRef.current.parentElement;\n      }\n      return null;\n    };\n    const menuContainer = React.createElement(Menu, {\n      ref: this.menuRef,\n      isScrollable: true\n    }, React.createElement(MenuContent, {\n      maxMenuHeight: \"200px\"\n    }, React.createElement(MenuList, {\n      \"aria-label\": ariaLabel\n    }, options.map((option, index) => React.createElement(MenuItem, {\n      onClick: this.onSelect,\n      key: option,\n      id: `${randomId}-option-${index}`\n    }, option)))));\n    const textInput = React.createElement(TextInput, Object.assign({\n      \"aria-haspopup\": \"menu\",\n      className: css(formStyles.formControl),\n      id: `${randomId}-input`,\n      \"aria-label\": ariaLabel,\n      validated: isInvalid ? 'error' : 'default',\n      placeholder: placeholder,\n      value: timeState || '',\n      type: \"text\",\n      iconVariant: \"clock\",\n      onClick: this.onInputClick,\n      onChange: this.onInputChange,\n      autoComplete: \"off\",\n      isDisabled: isDisabled,\n      ref: this.inputRef\n    }, inputProps));\n    let calculatedAppendTo;\n    switch (menuAppendTo) {\n      case 'inline':\n        calculatedAppendTo = () => this.toggleRef.current;\n        break;\n      case 'parent':\n        calculatedAppendTo = getParentElement;\n        break;\n      default:\n        calculatedAppendTo = menuAppendTo;\n    }\n    return React.createElement(\"div\", {\n      ref: this.baseComponentRef,\n      className: css(datePickerStyles.datePicker, className)\n    }, React.createElement(\"div\", Object.assign({\n      className: css(datePickerStyles.datePickerInput),\n      style: style\n    }, props), React.createElement(InputGroup, null, React.createElement(\"div\", {\n      id: randomId\n    }, React.createElement(\"div\", {\n      ref: this.toggleRef,\n      style: {\n        paddingLeft: '0'\n      }\n    }, React.createElement(Popper, {\n      appendTo: calculatedAppendTo,\n      trigger: textInput,\n      popper: menuContainer,\n      isVisible: isTimeOptionsOpen,\n      removeFindDomNode: removeFindDomNode,\n      zIndex: zIndex\n    })))), isInvalid && React.createElement(\"div\", {\n      className: css(datePickerStyles.datePickerHelperText, datePickerStyles.modifiers.error)\n    }, !isValidFormat ? invalidFormatErrorMessage : invalidMinMaxErrorMessage)));\n  }\n}\nTimePicker.displayName = 'TimePicker';\nTimePicker.defaultProps = {\n  className: '',\n  isDisabled: false,\n  time: '',\n  is24Hour: false,\n  invalidFormatErrorMessage: 'Invalid time format',\n  invalidMinMaxErrorMessage: 'Invalid time entered',\n  placeholder: 'hh:mm',\n  delimiter: ':',\n  'aria-label': 'Time picker',\n  width: '150px',\n  menuAppendTo: 'inline',\n  stepMinutes: 30,\n  inputProps: {},\n  minTime: '',\n  maxTime: '',\n  isOpen: false,\n  setIsOpen: () => {},\n  removeFindDomNode: false,\n  zIndex: 9999\n};","map":{"version":3,"sources":["../../../../src/components/TimePicker/TimePicker.tsx"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { __rest } from \"tslib\";\nimport * as React from 'react';\nimport { css } from '@patternfly/react-styles';\nimport datePickerStyles from '@patternfly/react-styles/css/components/DatePicker/date-picker';\nimport formStyles from '@patternfly/react-styles/css/components/FormControl/form-control';\nimport menuStyles from '@patternfly/react-styles/css/components/Menu/menu';\nimport { getUniqueId } from '../../helpers';\nimport { Popper } from '../../helpers/Popper/Popper';\nimport { Menu, MenuContent, MenuList, MenuItem } from '../Menu';\nimport { InputGroup } from '../InputGroup';\nimport { TextInput } from '../TextInput';\nimport { KeyTypes } from '../../helpers/constants';\nimport { parseTime, validateTime, makeTimeOptions, amSuffix, pmSuffix, getHours, getMinutes, isWithinMinMax, getSeconds } from './TimePickerUtils';\nexport class TimePicker extends React.Component {\n    constructor(props) {\n        super(props);\n        this.baseComponentRef = React.createRef();\n        this.toggleRef = React.createRef();\n        this.inputRef = React.createRef();\n        this.menuRef = React.createRef();\n        this.onDocClick = (event) => {\n            var _a, _b, _c, _d;\n            const clickedOnToggle = (_b = (_a = this.toggleRef) === null || _a === void 0 ? void 0 : _a.current) === null || _b === void 0 ? void 0 : _b.contains(event.target);\n            const clickedWithinMenu = (_d = (_c = this.menuRef) === null || _c === void 0 ? void 0 : _c.current) === null || _d === void 0 ? void 0 : _d.contains(event.target);\n            if (this.state.isTimeOptionsOpen && !(clickedOnToggle || clickedWithinMenu)) {\n                this.onToggle(false);\n            }\n        };\n        this.handleGlobalKeys = (event) => {\n            var _a, _b, _c, _d;\n            const { isTimeOptionsOpen, focusedIndex, scrollIndex } = this.state;\n            // keyboard pressed while focus on toggle\n            if ((_b = (_a = this.inputRef) === null || _a === void 0 ? void 0 : _a.current) === null || _b === void 0 ? void 0 : _b.contains(event.target)) {\n                if (!isTimeOptionsOpen && event.key !== KeyTypes.Tab && event.key !== KeyTypes.Escape) {\n                    this.onToggle(true);\n                }\n                else if (isTimeOptionsOpen) {\n                    if (event.key === KeyTypes.Escape || event.key === KeyTypes.Tab) {\n                        this.onToggle(false);\n                    }\n                    else if (event.key === KeyTypes.Enter) {\n                        if (focusedIndex !== null) {\n                            this.focusSelection(focusedIndex);\n                            event.stopPropagation();\n                        }\n                        else {\n                            this.onToggle(false);\n                        }\n                    }\n                    else if (event.key === KeyTypes.ArrowDown || event.key === KeyTypes.ArrowUp) {\n                        this.focusSelection(scrollIndex);\n                        this.updateFocusedIndex(0);\n                        event.preventDefault();\n                    }\n                }\n                // keyboard pressed while focus on menu item\n            }\n            else if ((_d = (_c = this.menuRef) === null || _c === void 0 ? void 0 : _c.current) === null || _d === void 0 ? void 0 : _d.contains(event.target)) {\n                if (event.key === KeyTypes.ArrowDown) {\n                    this.updateFocusedIndex(1);\n                    event.preventDefault();\n                }\n                else if (event.key === KeyTypes.ArrowUp) {\n                    this.updateFocusedIndex(-1);\n                    event.preventDefault();\n                }\n                else if (event.key === KeyTypes.Escape || event.key === KeyTypes.Tab) {\n                    this.inputRef.current.focus();\n                    this.onToggle(false);\n                }\n            }\n        };\n        this.updateFocusedIndex = (increment) => {\n            this.setState(prevState => {\n                const maxIndex = this.getOptions().length - 1;\n                let nextIndex = prevState.focusedIndex !== null ? prevState.focusedIndex + increment : prevState.scrollIndex + increment;\n                if (nextIndex < 0) {\n                    nextIndex = maxIndex;\n                }\n                else if (nextIndex > maxIndex) {\n                    nextIndex = 0;\n                }\n                this.scrollToIndex(nextIndex);\n                return {\n                    focusedIndex: nextIndex\n                };\n            });\n        };\n        // fixes issue where menutAppendTo=\"inline\" results in the menu item that should be scrolled to being out of view; this will select the menu item that comes before the intended one, causing that before-item to be placed out of view instead\n        this.getIndexToScroll = (index) => {\n            if (this.props.menuAppendTo === 'inline') {\n                return index > 0 ? index - 1 : 0;\n            }\n            return index;\n        };\n        this.scrollToIndex = (index) => {\n            this.getOptions()[index].closest(`.${menuStyles.menuContent}`).scrollTop = this.getOptions()[this.getIndexToScroll(index)].offsetTop;\n        };\n        this.focusSelection = (index) => {\n            var _a;\n            const indexToFocus = index !== -1 ? index : 0;\n            if ((_a = this.menuRef) === null || _a === void 0 ? void 0 : _a.current) {\n                this.getOptions()[indexToFocus].querySelector(`.${menuStyles.menuItem}`).focus();\n            }\n        };\n        this.scrollToSelection = (time) => {\n            const { delimiter, is24Hour } = this.props;\n            let splitTime = time.split(this.props.delimiter);\n            let focusedIndex = null;\n            // build out the rest of the time assuming hh:00 if it's a partial time\n            if (splitTime.length < 2) {\n                time = `${time}${delimiter}00`;\n                splitTime = time.split(delimiter);\n                // due to only the input including seconds when includeSeconds=true, we need to build a temporary time here without those seconds so that an exact or close match can be scrolled to within the menu (which does not include seconds in any of the options)\n            }\n            else if (splitTime.length > 2) {\n                time = parseTime(time, this.state.timeRegex, delimiter, !is24Hour, false);\n                splitTime = time.split(delimiter);\n            }\n            // for 12hr variant, autoscroll to pm if it's currently the afternoon, otherwise autoscroll to am\n            if (!is24Hour && splitTime.length > 1 && splitTime[1].length < 2) {\n                const minutes = splitTime[1].length === 0 ? '00' : splitTime[1] + '0';\n                time = `${splitTime[0]}${delimiter}${minutes}${new Date().getHours() > 11 ? pmSuffix : amSuffix}`;\n            }\n            else if (!is24Hour &&\n                splitTime.length > 1 &&\n                splitTime[1].length === 2 &&\n                !time.toUpperCase().includes(amSuffix.toUpperCase().trim()) &&\n                !time.toUpperCase().includes(pmSuffix.toUpperCase().trim())) {\n                time = `${time}${new Date().getHours() > 11 ? pmSuffix : amSuffix}`;\n            }\n            let scrollIndex = this.getOptions().findIndex(option => option.textContent === time);\n            // if we found an exact match, scroll to match and return index of match for focus\n            if (scrollIndex !== -1) {\n                this.scrollToIndex(scrollIndex);\n                focusedIndex = scrollIndex;\n            }\n            else if (splitTime.length === 2) {\n                // no exact match, scroll to closest hour but don't return index for focus\n                let amPm = '';\n                if (!is24Hour) {\n                    if (splitTime[1].toUpperCase().includes('P')) {\n                        amPm = pmSuffix;\n                    }\n                    else if (splitTime[1].toUpperCase().includes('A')) {\n                        amPm = amSuffix;\n                    }\n                }\n                time = `${splitTime[0]}${delimiter}00${amPm}`;\n                scrollIndex = this.getOptions().findIndex(option => option.textContent === time);\n                if (scrollIndex !== -1) {\n                    this.scrollToIndex(scrollIndex);\n                }\n            }\n            this.setState({\n                focusedIndex,\n                scrollIndex\n            });\n        };\n        this.getRegExp = (includeSeconds = true) => {\n            const { is24Hour, delimiter } = this.props;\n            let baseRegex = `\\\\s*(\\\\d\\\\d?)${delimiter}([0-5]\\\\d)`;\n            if (includeSeconds) {\n                baseRegex += `${delimiter}?([0-5]\\\\d)?`;\n            }\n            return new RegExp(`^${baseRegex}${is24Hour ? '' : '\\\\s*([AaPp][Mm])?'}\\\\s*$`);\n        };\n        this.getOptions = () => {\n            var _a;\n            return (((_a = this.menuRef) === null || _a === void 0 ? void 0 : _a.current)\n                ? Array.from(this.menuRef.current.querySelectorAll(`.${menuStyles.menuListItem}`))\n                : []);\n        };\n        this.isValidFormat = (time) => {\n            if (this.props.validateTime) {\n                return this.props.validateTime(time);\n            }\n            const { delimiter, is24Hour, includeSeconds } = this.props;\n            return validateTime(time, this.getRegExp(includeSeconds), delimiter, !is24Hour);\n        };\n        this.isValidTime = (time) => {\n            const { delimiter, includeSeconds } = this.props;\n            const { minTimeState, maxTimeState } = this.state;\n            return isWithinMinMax(minTimeState, maxTimeState, time, delimiter, includeSeconds);\n        };\n        this.isValid = (time) => this.isValidFormat(time) && this.isValidTime(time);\n        this.onToggle = (isOpen) => {\n            // on close, parse and validate input\n            this.setState(prevState => {\n                const { timeRegex, isInvalid, timeState } = prevState;\n                const { delimiter, is24Hour, includeSeconds, onChange } = this.props;\n                const time = parseTime(timeState, timeRegex, delimiter, !is24Hour, includeSeconds);\n                // Call onChange when Enter is pressed in input and timeoption does not exist in menu\n                if (onChange && !isOpen && time !== timeState) {\n                    onChange(null, time, getHours(time, timeRegex), getMinutes(time, timeRegex), getSeconds(time, timeRegex), this.isValid(time));\n                }\n                return {\n                    isTimeOptionsOpen: isOpen,\n                    timeState: time,\n                    isInvalid: isOpen ? isInvalid : !this.isValid(time)\n                };\n            });\n            this.props.setIsOpen(isOpen);\n            if (!isOpen) {\n                this.inputRef.current.focus();\n            }\n        };\n        this.onSelect = (e) => {\n            const { timeRegex, timeState } = this.state;\n            const { delimiter, is24Hour, includeSeconds, setIsOpen } = this.props;\n            const time = parseTime(e.target.textContent, timeRegex, delimiter, !is24Hour, includeSeconds);\n            if (time !== timeState) {\n                this.onInputChange(time, e);\n            }\n            this.inputRef.current.focus();\n            this.setState({\n                isTimeOptionsOpen: false,\n                isInvalid: false\n            });\n            setIsOpen(false);\n        };\n        this.onInputClick = (e) => {\n            if (!this.state.isTimeOptionsOpen) {\n                this.onToggle(true);\n            }\n            e.stopPropagation();\n        };\n        this.onInputChange = (newTime, event) => {\n            const { onChange } = this.props;\n            const { timeRegex } = this.state;\n            if (onChange) {\n                onChange(event, newTime, getHours(newTime, timeRegex), getMinutes(newTime, timeRegex), getSeconds(newTime, timeRegex), this.isValid(newTime));\n            }\n            this.scrollToSelection(newTime);\n            this.setState({\n                timeState: newTime\n            });\n        };\n        const { is24Hour, delimiter, time, includeSeconds, isOpen } = this.props;\n        let { minTime, maxTime } = this.props;\n        if (minTime === '') {\n            const minSeconds = includeSeconds ? `${delimiter}00` : '';\n            minTime = is24Hour ? `00${delimiter}00${minSeconds}` : `12${delimiter}00${minSeconds} AM`;\n        }\n        if (maxTime === '') {\n            const maxSeconds = includeSeconds ? `${delimiter}59` : '';\n            maxTime = is24Hour ? `23${delimiter}59${maxSeconds}` : `11${delimiter}59${maxSeconds} PM`;\n        }\n        const timeRegex = this.getRegExp();\n        this.state = {\n            isInvalid: false,\n            isTimeOptionsOpen: isOpen,\n            timeState: parseTime(time, timeRegex, delimiter, !is24Hour, includeSeconds),\n            focusedIndex: null,\n            scrollIndex: 0,\n            timeRegex,\n            minTimeState: parseTime(minTime, timeRegex, delimiter, !is24Hour, includeSeconds),\n            maxTimeState: parseTime(maxTime, timeRegex, delimiter, !is24Hour, includeSeconds)\n        };\n    }\n    componentDidMount() {\n        document.addEventListener('mousedown', this.onDocClick);\n        document.addEventListener('touchstart', this.onDocClick);\n        document.addEventListener('keydown', this.handleGlobalKeys);\n        this.setState({ isInvalid: !this.isValid(this.state.timeState) });\n    }\n    componentWillUnmount() {\n        document.removeEventListener('mousedown', this.onDocClick);\n        document.removeEventListener('touchstart', this.onDocClick);\n        document.removeEventListener('keydown', this.handleGlobalKeys);\n    }\n    componentDidUpdate(prevProps, prevState) {\n        const { timeState, isTimeOptionsOpen, isInvalid, timeRegex } = this.state;\n        const { time, is24Hour, delimiter, includeSeconds, isOpen, minTime, maxTime } = this.props;\n        if (prevProps.isOpen !== isOpen) {\n            this.onToggle(isOpen);\n        }\n        if (isTimeOptionsOpen && !prevState.isTimeOptionsOpen && timeState && !isInvalid) {\n            this.scrollToSelection(timeState);\n        }\n        if (delimiter !== prevProps.delimiter) {\n            this.setState({\n                timeRegex: this.getRegExp()\n            });\n        }\n        if (time !== '' && time !== prevProps.time) {\n            const parsedTime = parseTime(time, timeRegex, delimiter, !is24Hour, includeSeconds);\n            this.setState({\n                timeState: parsedTime,\n                isInvalid: !this.isValid(parsedTime)\n            });\n        }\n        if (minTime !== '' && minTime !== prevProps.minTime) {\n            this.setState({\n                minTimeState: parseTime(minTime, timeRegex, delimiter, !is24Hour, includeSeconds)\n            });\n        }\n        if (maxTime !== '' && maxTime !== prevProps.maxTime) {\n            this.setState({\n                maxTimeState: parseTime(maxTime, timeRegex, delimiter, !is24Hour, includeSeconds)\n            });\n        }\n    }\n    render() {\n        const _a = this.props, { 'aria-label': ariaLabel, isDisabled, className, placeholder, id, menuAppendTo, is24Hour, invalidFormatErrorMessage, invalidMinMaxErrorMessage, stepMinutes, width, delimiter, inputProps, \n        /* eslint-disable @typescript-eslint/no-unused-vars */\n        onChange, \n        /* eslint-disable @typescript-eslint/no-unused-vars */\n        setIsOpen, \n        /* eslint-disable @typescript-eslint/no-unused-vars */\n        isOpen, time, validateTime, minTime, maxTime, includeSeconds, \n        /* eslint-enable @typescript-eslint/no-unused-vars */\n        removeFindDomNode, zIndex } = _a, props = __rest(_a, ['aria-label', \"isDisabled\", \"className\", \"placeholder\", \"id\", \"menuAppendTo\", \"is24Hour\", \"invalidFormatErrorMessage\", \"invalidMinMaxErrorMessage\", \"stepMinutes\", \"width\", \"delimiter\", \"inputProps\", \"onChange\", \"setIsOpen\", \"isOpen\", \"time\", \"validateTime\", \"minTime\", \"maxTime\", \"includeSeconds\", \"removeFindDomNode\", \"zIndex\"]);\n        const { timeState, isTimeOptionsOpen, isInvalid, minTimeState, maxTimeState } = this.state;\n        const style = { '--pf-c-date-picker__input--c-form-control--Width': width };\n        const options = makeTimeOptions(stepMinutes, !is24Hour, delimiter, minTimeState, maxTimeState, includeSeconds);\n        const isValidFormat = this.isValidFormat(timeState);\n        const randomId = id || getUniqueId('time-picker');\n        const getParentElement = () => {\n            if (this.baseComponentRef && this.baseComponentRef.current) {\n                return this.baseComponentRef.current.parentElement;\n            }\n            return null;\n        };\n        const menuContainer = (React.createElement(Menu, { ref: this.menuRef, isScrollable: true },\n            React.createElement(MenuContent, { maxMenuHeight: \"200px\" },\n                React.createElement(MenuList, { \"aria-label\": ariaLabel }, options.map((option, index) => (React.createElement(MenuItem, { onClick: this.onSelect, key: option, id: `${randomId}-option-${index}` }, option)))))));\n        const textInput = (React.createElement(TextInput, Object.assign({ \"aria-haspopup\": \"menu\", className: css(formStyles.formControl), id: `${randomId}-input`, \"aria-label\": ariaLabel, validated: isInvalid ? 'error' : 'default', placeholder: placeholder, value: timeState || '', type: \"text\", iconVariant: \"clock\", onClick: this.onInputClick, onChange: this.onInputChange, autoComplete: \"off\", isDisabled: isDisabled, ref: this.inputRef }, inputProps)));\n        let calculatedAppendTo;\n        switch (menuAppendTo) {\n            case 'inline':\n                calculatedAppendTo = () => this.toggleRef.current;\n                break;\n            case 'parent':\n                calculatedAppendTo = getParentElement;\n                break;\n            default:\n                calculatedAppendTo = menuAppendTo;\n        }\n        return (React.createElement(\"div\", { ref: this.baseComponentRef, className: css(datePickerStyles.datePicker, className) },\n            React.createElement(\"div\", Object.assign({ className: css(datePickerStyles.datePickerInput), style: style }, props),\n                React.createElement(InputGroup, null,\n                    React.createElement(\"div\", { id: randomId },\n                        React.createElement(\"div\", { ref: this.toggleRef, style: { paddingLeft: '0' } },\n                            React.createElement(Popper, { appendTo: calculatedAppendTo, trigger: textInput, popper: menuContainer, isVisible: isTimeOptionsOpen, removeFindDomNode: removeFindDomNode, zIndex: zIndex })))),\n                isInvalid && (React.createElement(\"div\", { className: css(datePickerStyles.datePickerHelperText, datePickerStyles.modifiers.error) }, !isValidFormat ? invalidFormatErrorMessage : invalidMinMaxErrorMessage)))));\n    }\n}\nTimePicker.displayName = 'TimePicker';\nTimePicker.defaultProps = {\n    className: '',\n    isDisabled: false,\n    time: '',\n    is24Hour: false,\n    invalidFormatErrorMessage: 'Invalid time format',\n    invalidMinMaxErrorMessage: 'Invalid time entered',\n    placeholder: 'hh:mm',\n    delimiter: ':',\n    'aria-label': 'Time picker',\n    width: '150px',\n    menuAppendTo: 'inline',\n    stepMinutes: 30,\n    inputProps: {},\n    minTime: '',\n    maxTime: '',\n    isOpen: false,\n    setIsOpen: () => { },\n    removeFindDomNode: false,\n    zIndex: 9999\n};\n//# sourceMappingURL=TimePicker.js.map"]},"metadata":{},"sourceType":"module"}