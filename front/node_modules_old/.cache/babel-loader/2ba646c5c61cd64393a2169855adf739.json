{"ast":null,"code":"import { __rest } from \"tslib\";\nimport * as React from 'react';\nimport { createFocusTrap } from 'focus-trap';\nclass FocusTrapBase extends React.Component {\n  constructor(props) {\n    super(props);\n    this.divRef = this.props.innerRef || React.createRef();\n    if (typeof document !== 'undefined') {\n      this.previouslyFocusedElement = document.activeElement;\n    }\n  }\n  componentDidMount() {\n    // We need to hijack the returnFocusOnDeactivate option,\n    // because React can move focus into the element before we arrived at\n    // this lifecycle hook (e.g. with autoFocus inputs). So the component\n    // captures the previouslyFocusedElement in componentWillMount,\n    // then (optionally) returns focus to it in componentWillUnmount.\n    this.focusTrap = createFocusTrap(this.divRef.current, Object.assign(Object.assign({}, this.props.focusTrapOptions), {\n      returnFocusOnDeactivate: false\n    }));\n    if (this.props.active) {\n      this.focusTrap.activate();\n    }\n    if (this.props.paused) {\n      this.focusTrap.pause();\n    }\n  }\n  componentDidUpdate(prevProps) {\n    if (prevProps.active && !this.props.active) {\n      this.focusTrap.deactivate();\n    } else if (!prevProps.active && this.props.active) {\n      this.focusTrap.activate();\n    }\n    if (prevProps.paused && !this.props.paused) {\n      this.focusTrap.unpause();\n    } else if (!prevProps.paused && this.props.paused) {\n      this.focusTrap.pause();\n    }\n  }\n  componentWillUnmount() {\n    this.focusTrap.deactivate();\n    if (this.props.focusTrapOptions.returnFocusOnDeactivate !== false && this.previouslyFocusedElement && this.previouslyFocusedElement.focus) {\n      this.previouslyFocusedElement.focus({\n        preventScroll: this.props.preventScrollOnDeactivate\n      });\n    }\n  }\n  render() {\n    const _a = this.props,\n      {\n        children,\n        className,\n        /* eslint-disable @typescript-eslint/no-unused-vars */\n        focusTrapOptions,\n        active,\n        paused,\n        preventScrollOnDeactivate,\n        innerRef\n      } = _a,\n      /* eslint-enable @typescript-eslint/no-unused-vars */\n      rest = __rest(_a, [\"children\", \"className\", \"focusTrapOptions\", \"active\", \"paused\", \"preventScrollOnDeactivate\", \"innerRef\"]);\n    return React.createElement(\"div\", Object.assign({\n      ref: this.divRef,\n      className: className\n    }, rest), children);\n  }\n}\nFocusTrapBase.displayName = 'FocusTrap';\nFocusTrapBase.defaultProps = {\n  active: true,\n  paused: false,\n  focusTrapOptions: {},\n  preventScrollOnDeactivate: false\n};\nexport const FocusTrap = React.forwardRef((props, ref) => React.createElement(FocusTrapBase, Object.assign({\n  innerRef: ref\n}, props)));","map":{"version":3,"sources":["../../../../src/helpers/FocusTrap/FocusTrap.tsx"],"names":[],"mappings":";AAAA,OAAO,KAAK,KAAK,MAAM,OAAO;AAC9B,SAAS,eAAe,QAA8D,YAAY;AAclG,MAAM,aAAc,SAAQ,KAAK,CAAC,SAAyB,CAAA;EAazD,WAAA,CAAY,KAAqB,EAAA;IAC/B,KAAK,CAAC,KAAK,CAAC;IAVd,IAAA,CAAA,MAAM,GAAI,IAAI,CAAC,KAAK,CAAC,QAA4C,IAAI,KAAK,CAAC,SAAS,CAAA,CAAkB;IAYpG,IAAI,OAAO,QAAQ,KAAK,WAAW,EAAE;MACnC,IAAI,CAAC,wBAAwB,GAAG,QAAQ,CAAC,aAA4B;IACtE;EACH;EAEA,iBAAiB,CAAA,EAAA;IACf;IACA;IACA;IACA;IACA;IACA,IAAI,CAAC,SAAS,GAAG,eAAe,CAAC,IAAI,CAAC,MAAM,CAAC,OAAO,EAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,CAAA,CAAA,EAC/C,IAAI,CAAC,KAAK,CAAC,gBAAgB,CAAA,EAAA;MAC9B,uBAAuB,EAAE;IAAK,CAAA,CAAA,CAC9B;IACF,IAAI,IAAI,CAAC,KAAK,CAAC,MAAM,EAAE;MACrB,IAAI,CAAC,SAAS,CAAC,QAAQ,CAAA,CAAE;IAC1B;IACD,IAAI,IAAI,CAAC,KAAK,CAAC,MAAM,EAAE;MACrB,IAAI,CAAC,SAAS,CAAC,KAAK,CAAA,CAAE;IACvB;EACH;EAEA,kBAAkB,CAAC,SAAyB,EAAA;IAC1C,IAAI,SAAS,CAAC,MAAM,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,MAAM,EAAE;MAC1C,IAAI,CAAC,SAAS,CAAC,UAAU,CAAA,CAAE;KAC5B,MAAM,IAAI,CAAC,SAAS,CAAC,MAAM,IAAI,IAAI,CAAC,KAAK,CAAC,MAAM,EAAE;MACjD,IAAI,CAAC,SAAS,CAAC,QAAQ,CAAA,CAAE;IAC1B;IAED,IAAI,SAAS,CAAC,MAAM,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,MAAM,EAAE;MAC1C,IAAI,CAAC,SAAS,CAAC,OAAO,CAAA,CAAE;KACzB,MAAM,IAAI,CAAC,SAAS,CAAC,MAAM,IAAI,IAAI,CAAC,KAAK,CAAC,MAAM,EAAE;MACjD,IAAI,CAAC,SAAS,CAAC,KAAK,CAAA,CAAE;IACvB;EACH;EAEA,oBAAoB,CAAA,EAAA;IAClB,IAAI,CAAC,SAAS,CAAC,UAAU,CAAA,CAAE;IAC3B,IACE,IAAI,CAAC,KAAK,CAAC,gBAAgB,CAAC,uBAAuB,KAAK,KAAK,IAC7D,IAAI,CAAC,wBAAwB,IAC7B,IAAI,CAAC,wBAAwB,CAAC,KAAK,EACnC;MACA,IAAI,CAAC,wBAAwB,CAAC,KAAK,CAAC;QAAE,aAAa,EAAE,IAAI,CAAC,KAAK,CAAC;MAAyB,CAAE,CAAC;IAC7F;EACH;EAEA,MAAM,CAAA,EAAA;IACJ,MAAM,EAAA,GAWF,IAAI,CAAC,KAAK;MAXR;QACJ,QAAQ;QACR,SAAS;QACT;QACA,gBAAgB;QAChB,MAAM;QACN,MAAM;QACN,yBAAyB;QACzB;MAAQ,CAAA,GAAA,EAGI;MAFZ;MACG,IAAI,GAAA,MAAA,CAAA,EAAA,EAVH,CAAA,UAAA,EAAA,WAAA,EAAA,kBAAA,EAAA,QAAA,EAAA,QAAA,EAAA,2BAAA,EAAA,UAAA,CAWL,CAAa;IACd,OACE,KAAA,CAAA,aAAA,CAAA,KAAA,EAAA,MAAA,CAAA,MAAA,CAAA;MAAK,GAAG,EAAE,IAAI,CAAC,MAAM;MAAE,SAAS,EAAE;IAAS,CAAA,EAAM,IAAI,CAAA,EAClD,QAAQ,CACL;EAEV;;AAjFO,aAAA,CAAA,WAAW,GAAG,WAAW;AAKzB,aAAA,CAAA,YAAY,GAAG;EACpB,MAAM,EAAE,IAAI;EACZ,MAAM,EAAE,KAAK;EACb,gBAAgB,EAAE,CAAA,CAAE;EACpB,yBAAyB,EAAE;CAC5B;AA0EH,OAAO,MAAM,SAAS,GAAG,KAAK,CAAC,UAAU,CAAC,CAAC,KAAqB,EAAE,GAAmB,KACnF,KAAA,CAAA,aAAA,CAAC,aAAa,EAAA,MAAA,CAAA,MAAA,CAAA;EAAC,QAAQ,EAAE;AAAG,CAAA,EAAM,KAAK,CAAA,CACxC,CAAC","sourceRoot":"","sourcesContent":["import { __rest } from \"tslib\";\nimport * as React from 'react';\nimport { createFocusTrap } from 'focus-trap';\nclass FocusTrapBase extends React.Component {\n    constructor(props) {\n        super(props);\n        this.divRef = this.props.innerRef || React.createRef();\n        if (typeof document !== 'undefined') {\n            this.previouslyFocusedElement = document.activeElement;\n        }\n    }\n    componentDidMount() {\n        // We need to hijack the returnFocusOnDeactivate option,\n        // because React can move focus into the element before we arrived at\n        // this lifecycle hook (e.g. with autoFocus inputs). So the component\n        // captures the previouslyFocusedElement in componentWillMount,\n        // then (optionally) returns focus to it in componentWillUnmount.\n        this.focusTrap = createFocusTrap(this.divRef.current, Object.assign(Object.assign({}, this.props.focusTrapOptions), { returnFocusOnDeactivate: false }));\n        if (this.props.active) {\n            this.focusTrap.activate();\n        }\n        if (this.props.paused) {\n            this.focusTrap.pause();\n        }\n    }\n    componentDidUpdate(prevProps) {\n        if (prevProps.active && !this.props.active) {\n            this.focusTrap.deactivate();\n        }\n        else if (!prevProps.active && this.props.active) {\n            this.focusTrap.activate();\n        }\n        if (prevProps.paused && !this.props.paused) {\n            this.focusTrap.unpause();\n        }\n        else if (!prevProps.paused && this.props.paused) {\n            this.focusTrap.pause();\n        }\n    }\n    componentWillUnmount() {\n        this.focusTrap.deactivate();\n        if (this.props.focusTrapOptions.returnFocusOnDeactivate !== false &&\n            this.previouslyFocusedElement &&\n            this.previouslyFocusedElement.focus) {\n            this.previouslyFocusedElement.focus({ preventScroll: this.props.preventScrollOnDeactivate });\n        }\n    }\n    render() {\n        const _a = this.props, { children, className, \n        /* eslint-disable @typescript-eslint/no-unused-vars */\n        focusTrapOptions, active, paused, preventScrollOnDeactivate, innerRef } = _a, \n        /* eslint-enable @typescript-eslint/no-unused-vars */\n        rest = __rest(_a, [\"children\", \"className\", \"focusTrapOptions\", \"active\", \"paused\", \"preventScrollOnDeactivate\", \"innerRef\"]);\n        return (React.createElement(\"div\", Object.assign({ ref: this.divRef, className: className }, rest), children));\n    }\n}\nFocusTrapBase.displayName = 'FocusTrap';\nFocusTrapBase.defaultProps = {\n    active: true,\n    paused: false,\n    focusTrapOptions: {},\n    preventScrollOnDeactivate: false\n};\nexport const FocusTrap = React.forwardRef((props, ref) => (React.createElement(FocusTrapBase, Object.assign({ innerRef: ref }, props))));\n//# sourceMappingURL=FocusTrap.js.map"]},"metadata":{},"sourceType":"module"}