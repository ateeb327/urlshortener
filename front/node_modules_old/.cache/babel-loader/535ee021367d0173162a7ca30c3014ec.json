{"ast":null,"code":"import * as React from 'react';\nimport { EditColumn } from '../../EditColumn';\nimport tableStyles from '@patternfly/react-styles/css/components/Table/table';\nexport const editable = (label, {\n  rowIndex,\n  rowData,\n  column\n}) => {\n  const {\n    extraParams: {\n      onRowEdit\n    }\n  } = column;\n  const toggleEditMode = (event, type) => {\n    let validationErrors = {};\n    if (type === 'save') {\n      validationErrors = rowData.rowEditValidationRules && rowData.rowEditValidationRules.reduce((acc, rule) => {\n        const invalidCells = rowData.cells.filter(cellData => {\n          const testValue = cellData.props.editableValue === '' ? '' : cellData.props.editableValue || cellData.props.value;\n          let failedValidation = false;\n          if (Array.isArray(testValue) && testValue.length) {\n            // multiple values, like multiselect\n            failedValidation = testValue.reduce((hasInvalidSelection, el) => {\n              // if one value fails validation, the entire cell is invalid\n              if (hasInvalidSelection === true) {\n                return true;\n              }\n              return !rule.validator(el);\n            }, failedValidation);\n          } else if (Array.isArray(testValue) && !testValue.length) {\n            // case where all values were dismissed in multiselect\n            failedValidation = !rule.validator('');\n          } else {\n            // simple text fields\n            failedValidation = !rule.validator(testValue);\n          }\n          if (failedValidation) {\n            cellData.props.isValid = false;\n          }\n          return failedValidation;\n        });\n        if (invalidCells.length) {\n          acc[rule.name] = invalidCells.map(cell => cell.props.name);\n        }\n        return acc;\n      }, {});\n    }\n    // tslint:disable-next-line:no-unused-expression\n    onRowEdit(event, type, rowData && rowData.isEditable, rowIndex, validationErrors);\n  };\n  /**\n   * @param {number} identifier identifier used for the row\n   * @param {RowEditType} actionType the type of row edit action\n   */\n  function getAriaLabelTxt(identifier, actionType) {\n    let result;\n    switch (actionType) {\n      case 'cancel':\n        result = `Cancel row edits for row ${identifier}`;\n        break;\n      case 'save':\n        result = `Save row edits for row ${identifier}`;\n        break;\n      default:\n        result = `Place row ${identifier} in edit mode`;\n    }\n    return result;\n  }\n  return {\n    className: tableStyles.tableInlineEditAction,\n    component: 'td',\n    isVisible: true,\n    children: React.createElement(EditColumn, {\n      saveAriaLabel: rowData && rowData.rowSaveBtnAriaLabel && rowData.rowSaveBtnAriaLabel(rowIndex) || getAriaLabelTxt(rowIndex, 'save'),\n      cancelAriaLabel: rowData && rowData.rowCancelBtnAriaLabel && rowData.rowCancelBtnAriaLabel(rowIndex) || getAriaLabelTxt(rowIndex, 'cancel'),\n      editAriaLabel: rowData && rowData.rowEditBtnAriaLabel && rowData.rowEditBtnAriaLabel(rowIndex) || getAriaLabelTxt(rowIndex, 'edit'),\n      valid: rowData && rowData.isValid,\n      editing: rowData && rowData.isEditable,\n      onClick: toggleEditMode\n    })\n  };\n};","map":{"version":3,"sources":["../../../../../../src/components/Table/utils/decorators/editable.tsx"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import * as React from 'react';\nimport { EditColumn } from '../../EditColumn';\nimport tableStyles from '@patternfly/react-styles/css/components/Table/table';\nexport const editable = (label, { rowIndex, rowData, column }) => {\n    const { extraParams: { onRowEdit } } = column;\n    const toggleEditMode = (event, type) => {\n        let validationErrors = {};\n        if (type === 'save') {\n            validationErrors =\n                rowData.rowEditValidationRules &&\n                    rowData.rowEditValidationRules.reduce((acc, rule) => {\n                        const invalidCells = rowData.cells.filter(cellData => {\n                            const testValue = cellData.props.editableValue === '' ? '' : cellData.props.editableValue || cellData.props.value;\n                            let failedValidation = false;\n                            if (Array.isArray(testValue) && testValue.length) {\n                                // multiple values, like multiselect\n                                failedValidation = testValue.reduce((hasInvalidSelection, el) => {\n                                    // if one value fails validation, the entire cell is invalid\n                                    if (hasInvalidSelection === true) {\n                                        return true;\n                                    }\n                                    return !rule.validator(el);\n                                }, failedValidation);\n                            }\n                            else if (Array.isArray(testValue) && !testValue.length) {\n                                // case where all values were dismissed in multiselect\n                                failedValidation = !rule.validator('');\n                            }\n                            else {\n                                // simple text fields\n                                failedValidation = !rule.validator(testValue);\n                            }\n                            if (failedValidation) {\n                                cellData.props.isValid = false;\n                            }\n                            return failedValidation;\n                        });\n                        if (invalidCells.length) {\n                            acc[rule.name] = invalidCells.map(cell => cell.props.name);\n                        }\n                        return acc;\n                    }, {});\n        }\n        // tslint:disable-next-line:no-unused-expression\n        onRowEdit(event, type, rowData && rowData.isEditable, rowIndex, validationErrors);\n    };\n    /**\n     * @param {number} identifier identifier used for the row\n     * @param {RowEditType} actionType the type of row edit action\n     */\n    function getAriaLabelTxt(identifier, actionType) {\n        let result;\n        switch (actionType) {\n            case 'cancel':\n                result = `Cancel row edits for row ${identifier}`;\n                break;\n            case 'save':\n                result = `Save row edits for row ${identifier}`;\n                break;\n            default:\n                result = `Place row ${identifier} in edit mode`;\n        }\n        return result;\n    }\n    return {\n        className: tableStyles.tableInlineEditAction,\n        component: 'td',\n        isVisible: true,\n        children: (React.createElement(EditColumn, { saveAriaLabel: (rowData && rowData.rowSaveBtnAriaLabel && rowData.rowSaveBtnAriaLabel(rowIndex)) ||\n                getAriaLabelTxt(rowIndex, 'save'), cancelAriaLabel: (rowData && rowData.rowCancelBtnAriaLabel && rowData.rowCancelBtnAriaLabel(rowIndex)) ||\n                getAriaLabelTxt(rowIndex, 'cancel'), editAriaLabel: (rowData && rowData.rowEditBtnAriaLabel && rowData.rowEditBtnAriaLabel(rowIndex)) ||\n                getAriaLabelTxt(rowIndex, 'edit'), valid: rowData && rowData.isValid, editing: rowData && rowData.isEditable, onClick: toggleEditMode }))\n    };\n};\n//# sourceMappingURL=editable.js.map"]},"metadata":{},"sourceType":"module"}