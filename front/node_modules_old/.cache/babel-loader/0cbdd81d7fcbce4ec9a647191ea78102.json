{"ast":null,"code":"import * as ReactDOM from 'react-dom';\nimport { globalWidthBreakpoints, globalHeightBreakpoints, SIDE } from './constants';\n/**\n * @param {string} input - String to capitalize first letter\n */\nexport function capitalize(input) {\n  return input[0].toUpperCase() + input.substring(1);\n}\n/**\n * @param {string} prefix - String to prefix ID with\n */\nexport function getUniqueId(prefix = 'pf') {\n  const uid = new Date().getTime() + Math.random().toString(36).slice(2);\n  return `${prefix}-${uid}`;\n}\n/**\n * @param { any } this - \"This\" reference\n * @param { Function } func - Function to debounce\n * @param { number } wait - Debounce amount\n */\nexport function debounce(func, wait) {\n  let timeout;\n  return (...args) => {\n    clearTimeout(timeout);\n    timeout = setTimeout(() => func.apply(this, args), wait);\n  };\n}\n/** This function returns whether or not an element is within the viewable area of a container. If partial is true,\n * then this function will return true even if only part of the element is in view.\n *\n * @param {HTMLElement} container  The container to check if the element is in view of.\n * @param {HTMLElement} element    The element to check if it is view\n * @param {boolean} partial   true if partial view is allowed\n * @param {boolean} strict    true if strict mode is set, never consider the container width and element width\n *\n * @returns { boolean } True if the component is in View.\n */\nexport function isElementInView(container, element, partial, strict = false) {\n  if (!container || !element) {\n    return false;\n  }\n  const containerBounds = container.getBoundingClientRect();\n  const elementBounds = element.getBoundingClientRect();\n  const containerBoundsLeft = Math.ceil(containerBounds.left);\n  const containerBoundsRight = Math.floor(containerBounds.right);\n  const elementBoundsLeft = Math.ceil(elementBounds.left);\n  const elementBoundsRight = Math.floor(elementBounds.right);\n  // Check if in view\n  const isTotallyInView = elementBoundsLeft >= containerBoundsLeft && elementBoundsRight <= containerBoundsRight;\n  const isPartiallyInView = (partial || !strict && containerBounds.width < elementBounds.width) && (elementBoundsLeft < containerBoundsLeft && elementBoundsRight > containerBoundsLeft || elementBoundsRight > containerBoundsRight && elementBoundsLeft < containerBoundsRight);\n  // Return outcome\n  return isTotallyInView || isPartiallyInView;\n}\n/** This function returns the side the element is out of view on (right, left or both)\n *\n * @param {HTMLElement} container    The container to check if the element is in view of.\n * @param {HTMLElement} element      The element to check if it is view\n *\n * @returns {string} right if the element is of the right, left if element is off the left or both if it is off on both sides.\n */\nexport function sideElementIsOutOfView(container, element) {\n  const containerBounds = container.getBoundingClientRect();\n  const elementBounds = element.getBoundingClientRect();\n  const containerBoundsLeft = Math.floor(containerBounds.left);\n  const containerBoundsRight = Math.floor(containerBounds.right);\n  const elementBoundsLeft = Math.floor(elementBounds.left);\n  const elementBoundsRight = Math.floor(elementBounds.right);\n  // Check if in view\n  const isOffLeft = elementBoundsLeft < containerBoundsLeft;\n  const isOffRight = elementBoundsRight > containerBoundsRight;\n  let side = SIDE.NONE;\n  if (isOffRight && isOffLeft) {\n    side = SIDE.BOTH;\n  } else if (isOffRight) {\n    side = SIDE.RIGHT;\n  } else if (isOffLeft) {\n    side = SIDE.LEFT;\n  }\n  // Return outcome\n  return side;\n}\n/** Interpolates a parameterized templateString using values from a templateVars object.\n * The templateVars object should have keys and values which match the templateString's parameters.\n * Example:\n *    const templateString: 'My name is ${firstName} ${lastName}';\n *    const templateVars: {\n *      firstName: 'Jon'\n *      lastName: 'Dough'\n *    };\n *    const result = fillTemplate(templateString, templateVars);\n *    // \"My name is Jon Dough\"\n *\n * @param {string} templateString  The string passed by the consumer\n * @param {object} templateVars The variables passed to the string\n *\n * @returns {string} The template string literal result\n */\nexport function fillTemplate(templateString, templateVars) {\n  return templateString.replace(/\\${(.*?)}/g, (_, match) => templateVars[match] || '');\n}\n/**\n * This function allows for keyboard navigation through dropdowns. The custom argument is optional.\n *\n * @param {number} index The index of the element you're on\n * @param {number} innerIndex Inner index number\n * @param {string} position The orientation of the dropdown\n * @param {string[]} refsCollection Array of refs to the items in the dropdown\n * @param {object[]} kids Array of items in the dropdown\n * @param {boolean} [custom] Allows for handling of flexible content\n */\nexport function keyHandler(index, innerIndex, position, refsCollection, kids, custom = false) {\n  if (!Array.isArray(kids)) {\n    return;\n  }\n  const isMultiDimensional = refsCollection.filter(ref => ref)[0].constructor === Array;\n  let nextIndex = index;\n  let nextInnerIndex = innerIndex;\n  if (position === 'up') {\n    if (index === 0) {\n      // loop back to end\n      nextIndex = kids.length - 1;\n    } else {\n      nextIndex = index - 1;\n    }\n  } else if (position === 'down') {\n    if (index === kids.length - 1) {\n      // loop back to beginning\n      nextIndex = 0;\n    } else {\n      nextIndex = index + 1;\n    }\n  } else if (position === 'left') {\n    if (innerIndex === 0) {\n      nextInnerIndex = refsCollection[index].length - 1;\n    } else {\n      nextInnerIndex = innerIndex - 1;\n    }\n  } else if (position === 'right') {\n    if (innerIndex === refsCollection[index].length - 1) {\n      nextInnerIndex = 0;\n    } else {\n      nextInnerIndex = innerIndex + 1;\n    }\n  }\n  if (refsCollection[nextIndex] === null || refsCollection[nextIndex] === undefined || isMultiDimensional && (refsCollection[nextIndex][nextInnerIndex] === null || refsCollection[nextIndex][nextInnerIndex] === undefined)) {\n    keyHandler(nextIndex, nextInnerIndex, position, refsCollection, kids, custom);\n  } else if (custom) {\n    if (refsCollection[nextIndex].focus) {\n      refsCollection[nextIndex].focus();\n    }\n    // eslint-disable-next-line react/no-find-dom-node\n    const element = ReactDOM.findDOMNode(refsCollection[nextIndex]);\n    element.focus();\n  } else if (position !== 'tab') {\n    if (isMultiDimensional) {\n      refsCollection[nextIndex][nextInnerIndex].focus();\n    } else {\n      refsCollection[nextIndex].focus();\n    }\n  }\n}\n/** This function returns a list of tabbable items in a container\n *\n *  @param {any} containerRef to the container\n *  @param {string} tababbleSelectors CSS selector string of tabbable items\n */\nexport function findTabbableElements(containerRef, tababbleSelectors) {\n  const tabbable = containerRef.current.querySelectorAll(tababbleSelectors);\n  const list = Array.prototype.filter.call(tabbable, function (item) {\n    return item.tabIndex >= '0';\n  });\n  return list;\n}\n/** This function is a helper for keyboard navigation through dropdowns.\n *\n * @param {number} index The index of the element you're on\n * @param {string} position The orientation of the dropdown\n * @param {string[]} collection Array of refs to the items in the dropdown\n */\nexport function getNextIndex(index, position, collection) {\n  let nextIndex;\n  if (position === 'up') {\n    if (index === 0) {\n      // loop back to end\n      nextIndex = collection.length - 1;\n    } else {\n      nextIndex = index - 1;\n    }\n  } else if (index === collection.length - 1) {\n    // loop back to beginning\n    nextIndex = 0;\n  } else {\n    nextIndex = index + 1;\n  }\n  if (collection[nextIndex] === undefined || collection[nextIndex][0] === null) {\n    return getNextIndex(nextIndex, position, collection);\n  } else {\n    return nextIndex;\n  }\n}\n/** This function is a helper for pluralizing strings.\n *\n * @param {number} i The quantity of the string you want to pluralize\n * @param {string} singular The singular version of the string\n * @param {string} plural The change to the string that should occur if the quantity is not equal to 1.\n *                 Defaults to adding an 's'.\n */\nexport function pluralize(i, singular, plural) {\n  if (!plural) {\n    plural = `${singular}s`;\n  }\n  return `${i || 0} ${i === 1 ? singular : plural}`;\n}\n/**\n * This function is a helper for turning arrays of breakpointMod objects for flex and grid into style object\n *\n * @param {object} mods The modifiers object\n * @param {string} css-variable The appropriate css variable for the component\n */\nexport const setBreakpointCssVars = (mods, cssVar) => Object.entries(mods || {}).reduce((acc, [breakpoint, value]) => breakpoint === 'default' ? Object.assign(Object.assign({}, acc), {\n  [cssVar]: value\n}) : Object.assign(Object.assign({}, acc), {\n  [`${cssVar}-on-${breakpoint}`]: value\n}), {});\n/**\n * This function is a helper for turning arrays of breakpointMod objects for data toolbar and flex into classes\n *\n * @param {object} mods The modifiers object\n * @param {any} styles The appropriate styles object for the component\n */\nexport const formatBreakpointMods = (mods, styles, stylePrefix = '', breakpoint, vertical) => {\n  if (!mods) {\n    return '';\n  }\n  if (breakpoint && !vertical) {\n    if (breakpoint in mods) {\n      return styles.modifiers[toCamel(`${stylePrefix}${mods[breakpoint]}`)];\n    }\n    // the current breakpoint is not specified in mods, so we try to find the next nearest\n    const breakpointsOrder = ['2xl', 'xl', 'lg', 'md', 'sm', 'default'];\n    const breakpointsIndex = breakpointsOrder.indexOf(breakpoint);\n    for (let i = breakpointsIndex; i < breakpointsOrder.length; i++) {\n      if (breakpointsOrder[i] in mods) {\n        return styles.modifiers[toCamel(`${stylePrefix}${mods[breakpointsOrder[i]]}`)];\n      }\n    }\n    return '';\n  }\n  return Object.entries(mods || {}).map(([breakpoint, mod]) => `${stylePrefix}${mod}${breakpoint !== 'default' ? `-on-${breakpoint}` : ''}${vertical && breakpoint !== 'default' ? '-height' : ''}`).map(toCamel).map(mod => mod.replace(/-?(\\dxl)/gi, (_res, group) => `_${group}`)).map(modifierKey => styles.modifiers[modifierKey]).filter(Boolean).join(' ');\n};\n/**\n * Return the breakpoint for the given height\n *\n * @param {number | null} height The height to check\n * @returns {'default' | 'sm' | 'md' | 'lg' | 'xl' | '2xl'} The breakpoint\n */\nexport const getVerticalBreakpoint = height => {\n  if (height === null) {\n    return null;\n  }\n  if (height >= globalHeightBreakpoints['2xl']) {\n    return '2xl';\n  }\n  if (height >= globalHeightBreakpoints.xl) {\n    return 'xl';\n  }\n  if (height >= globalHeightBreakpoints.lg) {\n    return 'lg';\n  }\n  if (height >= globalHeightBreakpoints.md) {\n    return 'md';\n  }\n  if (height >= globalHeightBreakpoints.sm) {\n    return 'sm';\n  }\n  return 'default';\n};\n/**\n * Return the breakpoint for the given width\n *\n * @param {number | null} width The width to check\n * @returns {'default' | 'sm' | 'md' | 'lg' | 'xl' | '2xl'} The breakpoint\n */\nexport const getBreakpoint = width => {\n  if (width === null) {\n    return null;\n  }\n  if (width >= globalWidthBreakpoints['2xl']) {\n    return '2xl';\n  }\n  if (width >= globalWidthBreakpoints.xl) {\n    return 'xl';\n  }\n  if (width >= globalWidthBreakpoints.lg) {\n    return 'lg';\n  }\n  if (width >= globalWidthBreakpoints.md) {\n    return 'md';\n  }\n  if (width >= globalWidthBreakpoints.sm) {\n    return 'sm';\n  }\n  return 'default';\n};\nconst camelize = s => s.toUpperCase().replace('-', '').replace('_', '');\n/**\n *\n * @param {string} s string to make camelCased\n */\nexport const toCamel = s => s.replace(/([-_][a-z])/gi, camelize);\n/**\n * Copied from exenv\n */\nexport const canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);\n/**\n * Calculate the width of the text\n * Example:\n * getTextWidth('my text', node)\n *\n * @param {string} text The text to calculate the width for\n * @param {HTMLElement} node The HTML element\n */\nexport const getTextWidth = (text, node) => {\n  const computedStyle = getComputedStyle(node);\n  // Firefox returns the empty string for .font, so this function creates the .font property manually\n  const getFontFromComputedStyle = () => {\n    let computedFont = '';\n    // Firefox uses percentages for font-stretch, but Canvas does not accept percentages\n    // so convert to keywords, as listed at:\n    // https://developer.mozilla.org/en-US/docs/Web/CSS/font-stretch\n    const fontStretchLookupTable = {\n      '50%': 'ultra-condensed',\n      '62.5%': 'extra-condensed',\n      '75%': 'condensed',\n      '87.5%': 'semi-condensed',\n      '100%': 'normal',\n      '112.5%': 'semi-expanded',\n      '125%': 'expanded',\n      '150%': 'extra-expanded',\n      '200%': 'ultra-expanded'\n    };\n    // If the retrieved font-stretch percentage isn't found in the lookup table, use\n    // 'normal' as a last resort.\n    let fontStretch;\n    if (computedStyle.fontStretch in fontStretchLookupTable) {\n      fontStretch = fontStretchLookupTable[computedStyle.fontStretch];\n    } else {\n      fontStretch = 'normal';\n    }\n    computedFont = computedStyle.fontStyle + ' ' + computedStyle.fontVariant + ' ' + computedStyle.fontWeight + ' ' + fontStretch + ' ' + computedStyle.fontSize + '/' + computedStyle.lineHeight + ' ' + computedStyle.fontFamily;\n    return computedFont;\n  };\n  const canvas = document.createElement('canvas');\n  const context = canvas.getContext('2d');\n  context.font = computedStyle.font || getFontFromComputedStyle();\n  return context.measureText(text).width;\n};\n/**\n * Get the inner dimensions of an element\n *\n * @param {HTMLElement} node HTML element to calculate the inner dimensions for\n */\nexport const innerDimensions = node => {\n  const computedStyle = getComputedStyle(node);\n  let width = node.clientWidth; // width with padding\n  let height = node.clientHeight; // height with padding\n  height -= parseFloat(computedStyle.paddingTop) + parseFloat(computedStyle.paddingBottom);\n  width -= parseFloat(computedStyle.paddingLeft) + parseFloat(computedStyle.paddingRight);\n  return {\n    height,\n    width\n  };\n};\n/**\n * This function is a helper for truncating text content on the left, leaving the right side of the content in view\n *\n * @param {HTMLElement} node HTML element\n * @param {string} value The original text value\n */\nexport const trimLeft = (node, value) => {\n  const availableWidth = innerDimensions(node).width;\n  let newValue = value;\n  if (getTextWidth(value, node) > availableWidth) {\n    // we have text overflow, trim the text to the left and add ... in the front until it fits\n    while (getTextWidth(`...${newValue}`, node) > availableWidth) {\n      newValue = newValue.substring(1);\n    }\n    // replace text with our truncated text\n    if (node.value) {\n      node.value = `...${newValue}`;\n    } else {\n      node.innerText = `...${newValue}`;\n    }\n  } else {\n    if (node.value) {\n      node.value = value;\n    } else {\n      node.innerText = value;\n    }\n  }\n};\n/**\n * @param {string[]} events - Operations to prevent when disabled\n */\nexport const preventedEvents = events => events.reduce((handlers, eventToPrevent) => Object.assign(Object.assign({}, handlers), {\n  [eventToPrevent]: event => {\n    event.preventDefault();\n  }\n}), {});","map":{"version":3,"sources":["../../../src/helpers/util.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import * as ReactDOM from 'react-dom';\nimport { globalWidthBreakpoints, globalHeightBreakpoints, SIDE } from './constants';\n/**\n * @param {string} input - String to capitalize first letter\n */\nexport function capitalize(input) {\n    return input[0].toUpperCase() + input.substring(1);\n}\n/**\n * @param {string} prefix - String to prefix ID with\n */\nexport function getUniqueId(prefix = 'pf') {\n    const uid = new Date().getTime() +\n        Math.random()\n            .toString(36)\n            .slice(2);\n    return `${prefix}-${uid}`;\n}\n/**\n * @param { any } this - \"This\" reference\n * @param { Function } func - Function to debounce\n * @param { number } wait - Debounce amount\n */\nexport function debounce(func, wait) {\n    let timeout;\n    return (...args) => {\n        clearTimeout(timeout);\n        timeout = setTimeout(() => func.apply(this, args), wait);\n    };\n}\n/** This function returns whether or not an element is within the viewable area of a container. If partial is true,\n * then this function will return true even if only part of the element is in view.\n *\n * @param {HTMLElement} container  The container to check if the element is in view of.\n * @param {HTMLElement} element    The element to check if it is view\n * @param {boolean} partial   true if partial view is allowed\n * @param {boolean} strict    true if strict mode is set, never consider the container width and element width\n *\n * @returns { boolean } True if the component is in View.\n */\nexport function isElementInView(container, element, partial, strict = false) {\n    if (!container || !element) {\n        return false;\n    }\n    const containerBounds = container.getBoundingClientRect();\n    const elementBounds = element.getBoundingClientRect();\n    const containerBoundsLeft = Math.ceil(containerBounds.left);\n    const containerBoundsRight = Math.floor(containerBounds.right);\n    const elementBoundsLeft = Math.ceil(elementBounds.left);\n    const elementBoundsRight = Math.floor(elementBounds.right);\n    // Check if in view\n    const isTotallyInView = elementBoundsLeft >= containerBoundsLeft && elementBoundsRight <= containerBoundsRight;\n    const isPartiallyInView = (partial || (!strict && containerBounds.width < elementBounds.width)) &&\n        ((elementBoundsLeft < containerBoundsLeft && elementBoundsRight > containerBoundsLeft) ||\n            (elementBoundsRight > containerBoundsRight && elementBoundsLeft < containerBoundsRight));\n    // Return outcome\n    return isTotallyInView || isPartiallyInView;\n}\n/** This function returns the side the element is out of view on (right, left or both)\n *\n * @param {HTMLElement} container    The container to check if the element is in view of.\n * @param {HTMLElement} element      The element to check if it is view\n *\n * @returns {string} right if the element is of the right, left if element is off the left or both if it is off on both sides.\n */\nexport function sideElementIsOutOfView(container, element) {\n    const containerBounds = container.getBoundingClientRect();\n    const elementBounds = element.getBoundingClientRect();\n    const containerBoundsLeft = Math.floor(containerBounds.left);\n    const containerBoundsRight = Math.floor(containerBounds.right);\n    const elementBoundsLeft = Math.floor(elementBounds.left);\n    const elementBoundsRight = Math.floor(elementBounds.right);\n    // Check if in view\n    const isOffLeft = elementBoundsLeft < containerBoundsLeft;\n    const isOffRight = elementBoundsRight > containerBoundsRight;\n    let side = SIDE.NONE;\n    if (isOffRight && isOffLeft) {\n        side = SIDE.BOTH;\n    }\n    else if (isOffRight) {\n        side = SIDE.RIGHT;\n    }\n    else if (isOffLeft) {\n        side = SIDE.LEFT;\n    }\n    // Return outcome\n    return side;\n}\n/** Interpolates a parameterized templateString using values from a templateVars object.\n * The templateVars object should have keys and values which match the templateString's parameters.\n * Example:\n *    const templateString: 'My name is ${firstName} ${lastName}';\n *    const templateVars: {\n *      firstName: 'Jon'\n *      lastName: 'Dough'\n *    };\n *    const result = fillTemplate(templateString, templateVars);\n *    // \"My name is Jon Dough\"\n *\n * @param {string} templateString  The string passed by the consumer\n * @param {object} templateVars The variables passed to the string\n *\n * @returns {string} The template string literal result\n */\nexport function fillTemplate(templateString, templateVars) {\n    return templateString.replace(/\\${(.*?)}/g, (_, match) => templateVars[match] || '');\n}\n/**\n * This function allows for keyboard navigation through dropdowns. The custom argument is optional.\n *\n * @param {number} index The index of the element you're on\n * @param {number} innerIndex Inner index number\n * @param {string} position The orientation of the dropdown\n * @param {string[]} refsCollection Array of refs to the items in the dropdown\n * @param {object[]} kids Array of items in the dropdown\n * @param {boolean} [custom] Allows for handling of flexible content\n */\nexport function keyHandler(index, innerIndex, position, refsCollection, kids, custom = false) {\n    if (!Array.isArray(kids)) {\n        return;\n    }\n    const isMultiDimensional = refsCollection.filter(ref => ref)[0].constructor === Array;\n    let nextIndex = index;\n    let nextInnerIndex = innerIndex;\n    if (position === 'up') {\n        if (index === 0) {\n            // loop back to end\n            nextIndex = kids.length - 1;\n        }\n        else {\n            nextIndex = index - 1;\n        }\n    }\n    else if (position === 'down') {\n        if (index === kids.length - 1) {\n            // loop back to beginning\n            nextIndex = 0;\n        }\n        else {\n            nextIndex = index + 1;\n        }\n    }\n    else if (position === 'left') {\n        if (innerIndex === 0) {\n            nextInnerIndex = refsCollection[index].length - 1;\n        }\n        else {\n            nextInnerIndex = innerIndex - 1;\n        }\n    }\n    else if (position === 'right') {\n        if (innerIndex === refsCollection[index].length - 1) {\n            nextInnerIndex = 0;\n        }\n        else {\n            nextInnerIndex = innerIndex + 1;\n        }\n    }\n    if (refsCollection[nextIndex] === null ||\n        refsCollection[nextIndex] === undefined ||\n        (isMultiDimensional &&\n            (refsCollection[nextIndex][nextInnerIndex] === null || refsCollection[nextIndex][nextInnerIndex] === undefined))) {\n        keyHandler(nextIndex, nextInnerIndex, position, refsCollection, kids, custom);\n    }\n    else if (custom) {\n        if (refsCollection[nextIndex].focus) {\n            refsCollection[nextIndex].focus();\n        }\n        // eslint-disable-next-line react/no-find-dom-node\n        const element = ReactDOM.findDOMNode(refsCollection[nextIndex]);\n        element.focus();\n    }\n    else if (position !== 'tab') {\n        if (isMultiDimensional) {\n            refsCollection[nextIndex][nextInnerIndex].focus();\n        }\n        else {\n            refsCollection[nextIndex].focus();\n        }\n    }\n}\n/** This function returns a list of tabbable items in a container\n *\n *  @param {any} containerRef to the container\n *  @param {string} tababbleSelectors CSS selector string of tabbable items\n */\nexport function findTabbableElements(containerRef, tababbleSelectors) {\n    const tabbable = containerRef.current.querySelectorAll(tababbleSelectors);\n    const list = Array.prototype.filter.call(tabbable, function (item) {\n        return item.tabIndex >= '0';\n    });\n    return list;\n}\n/** This function is a helper for keyboard navigation through dropdowns.\n *\n * @param {number} index The index of the element you're on\n * @param {string} position The orientation of the dropdown\n * @param {string[]} collection Array of refs to the items in the dropdown\n */\nexport function getNextIndex(index, position, collection) {\n    let nextIndex;\n    if (position === 'up') {\n        if (index === 0) {\n            // loop back to end\n            nextIndex = collection.length - 1;\n        }\n        else {\n            nextIndex = index - 1;\n        }\n    }\n    else if (index === collection.length - 1) {\n        // loop back to beginning\n        nextIndex = 0;\n    }\n    else {\n        nextIndex = index + 1;\n    }\n    if (collection[nextIndex] === undefined || collection[nextIndex][0] === null) {\n        return getNextIndex(nextIndex, position, collection);\n    }\n    else {\n        return nextIndex;\n    }\n}\n/** This function is a helper for pluralizing strings.\n *\n * @param {number} i The quantity of the string you want to pluralize\n * @param {string} singular The singular version of the string\n * @param {string} plural The change to the string that should occur if the quantity is not equal to 1.\n *                 Defaults to adding an 's'.\n */\nexport function pluralize(i, singular, plural) {\n    if (!plural) {\n        plural = `${singular}s`;\n    }\n    return `${i || 0} ${i === 1 ? singular : plural}`;\n}\n/**\n * This function is a helper for turning arrays of breakpointMod objects for flex and grid into style object\n *\n * @param {object} mods The modifiers object\n * @param {string} css-variable The appropriate css variable for the component\n */\nexport const setBreakpointCssVars = (mods, cssVar) => Object.entries(mods || {}).reduce((acc, [breakpoint, value]) => breakpoint === 'default' ? Object.assign(Object.assign({}, acc), { [cssVar]: value }) : Object.assign(Object.assign({}, acc), { [`${cssVar}-on-${breakpoint}`]: value }), {});\n/**\n * This function is a helper for turning arrays of breakpointMod objects for data toolbar and flex into classes\n *\n * @param {object} mods The modifiers object\n * @param {any} styles The appropriate styles object for the component\n */\nexport const formatBreakpointMods = (mods, styles, stylePrefix = '', breakpoint, vertical) => {\n    if (!mods) {\n        return '';\n    }\n    if (breakpoint && !vertical) {\n        if (breakpoint in mods) {\n            return styles.modifiers[toCamel(`${stylePrefix}${mods[breakpoint]}`)];\n        }\n        // the current breakpoint is not specified in mods, so we try to find the next nearest\n        const breakpointsOrder = ['2xl', 'xl', 'lg', 'md', 'sm', 'default'];\n        const breakpointsIndex = breakpointsOrder.indexOf(breakpoint);\n        for (let i = breakpointsIndex; i < breakpointsOrder.length; i++) {\n            if (breakpointsOrder[i] in mods) {\n                return styles.modifiers[toCamel(`${stylePrefix}${mods[breakpointsOrder[i]]}`)];\n            }\n        }\n        return '';\n    }\n    return Object.entries(mods || {})\n        .map(([breakpoint, mod]) => `${stylePrefix}${mod}${breakpoint !== 'default' ? `-on-${breakpoint}` : ''}${vertical && breakpoint !== 'default' ? '-height' : ''}`)\n        .map(toCamel)\n        .map(mod => mod.replace(/-?(\\dxl)/gi, (_res, group) => `_${group}`))\n        .map(modifierKey => styles.modifiers[modifierKey])\n        .filter(Boolean)\n        .join(' ');\n};\n/**\n * Return the breakpoint for the given height\n *\n * @param {number | null} height The height to check\n * @returns {'default' | 'sm' | 'md' | 'lg' | 'xl' | '2xl'} The breakpoint\n */\nexport const getVerticalBreakpoint = (height) => {\n    if (height === null) {\n        return null;\n    }\n    if (height >= globalHeightBreakpoints['2xl']) {\n        return '2xl';\n    }\n    if (height >= globalHeightBreakpoints.xl) {\n        return 'xl';\n    }\n    if (height >= globalHeightBreakpoints.lg) {\n        return 'lg';\n    }\n    if (height >= globalHeightBreakpoints.md) {\n        return 'md';\n    }\n    if (height >= globalHeightBreakpoints.sm) {\n        return 'sm';\n    }\n    return 'default';\n};\n/**\n * Return the breakpoint for the given width\n *\n * @param {number | null} width The width to check\n * @returns {'default' | 'sm' | 'md' | 'lg' | 'xl' | '2xl'} The breakpoint\n */\nexport const getBreakpoint = (width) => {\n    if (width === null) {\n        return null;\n    }\n    if (width >= globalWidthBreakpoints['2xl']) {\n        return '2xl';\n    }\n    if (width >= globalWidthBreakpoints.xl) {\n        return 'xl';\n    }\n    if (width >= globalWidthBreakpoints.lg) {\n        return 'lg';\n    }\n    if (width >= globalWidthBreakpoints.md) {\n        return 'md';\n    }\n    if (width >= globalWidthBreakpoints.sm) {\n        return 'sm';\n    }\n    return 'default';\n};\nconst camelize = (s) => s\n    .toUpperCase()\n    .replace('-', '')\n    .replace('_', '');\n/**\n *\n * @param {string} s string to make camelCased\n */\nexport const toCamel = (s) => s.replace(/([-_][a-z])/gi, camelize);\n/**\n * Copied from exenv\n */\nexport const canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);\n/**\n * Calculate the width of the text\n * Example:\n * getTextWidth('my text', node)\n *\n * @param {string} text The text to calculate the width for\n * @param {HTMLElement} node The HTML element\n */\nexport const getTextWidth = (text, node) => {\n    const computedStyle = getComputedStyle(node);\n    // Firefox returns the empty string for .font, so this function creates the .font property manually\n    const getFontFromComputedStyle = () => {\n        let computedFont = '';\n        // Firefox uses percentages for font-stretch, but Canvas does not accept percentages\n        // so convert to keywords, as listed at:\n        // https://developer.mozilla.org/en-US/docs/Web/CSS/font-stretch\n        const fontStretchLookupTable = {\n            '50%': 'ultra-condensed',\n            '62.5%': 'extra-condensed',\n            '75%': 'condensed',\n            '87.5%': 'semi-condensed',\n            '100%': 'normal',\n            '112.5%': 'semi-expanded',\n            '125%': 'expanded',\n            '150%': 'extra-expanded',\n            '200%': 'ultra-expanded'\n        };\n        // If the retrieved font-stretch percentage isn't found in the lookup table, use\n        // 'normal' as a last resort.\n        let fontStretch;\n        if (computedStyle.fontStretch in fontStretchLookupTable) {\n            fontStretch = fontStretchLookupTable[computedStyle.fontStretch];\n        }\n        else {\n            fontStretch = 'normal';\n        }\n        computedFont =\n            computedStyle.fontStyle +\n                ' ' +\n                computedStyle.fontVariant +\n                ' ' +\n                computedStyle.fontWeight +\n                ' ' +\n                fontStretch +\n                ' ' +\n                computedStyle.fontSize +\n                '/' +\n                computedStyle.lineHeight +\n                ' ' +\n                computedStyle.fontFamily;\n        return computedFont;\n    };\n    const canvas = document.createElement('canvas');\n    const context = canvas.getContext('2d');\n    context.font = computedStyle.font || getFontFromComputedStyle();\n    return context.measureText(text).width;\n};\n/**\n * Get the inner dimensions of an element\n *\n * @param {HTMLElement} node HTML element to calculate the inner dimensions for\n */\nexport const innerDimensions = (node) => {\n    const computedStyle = getComputedStyle(node);\n    let width = node.clientWidth; // width with padding\n    let height = node.clientHeight; // height with padding\n    height -= parseFloat(computedStyle.paddingTop) + parseFloat(computedStyle.paddingBottom);\n    width -= parseFloat(computedStyle.paddingLeft) + parseFloat(computedStyle.paddingRight);\n    return { height, width };\n};\n/**\n * This function is a helper for truncating text content on the left, leaving the right side of the content in view\n *\n * @param {HTMLElement} node HTML element\n * @param {string} value The original text value\n */\nexport const trimLeft = (node, value) => {\n    const availableWidth = innerDimensions(node).width;\n    let newValue = value;\n    if (getTextWidth(value, node) > availableWidth) {\n        // we have text overflow, trim the text to the left and add ... in the front until it fits\n        while (getTextWidth(`...${newValue}`, node) > availableWidth) {\n            newValue = newValue.substring(1);\n        }\n        // replace text with our truncated text\n        if (node.value) {\n            node.value = `...${newValue}`;\n        }\n        else {\n            node.innerText = `...${newValue}`;\n        }\n    }\n    else {\n        if (node.value) {\n            node.value = value;\n        }\n        else {\n            node.innerText = value;\n        }\n    }\n};\n/**\n * @param {string[]} events - Operations to prevent when disabled\n */\nexport const preventedEvents = (events) => events.reduce((handlers, eventToPrevent) => (Object.assign(Object.assign({}, handlers), { [eventToPrevent]: (event) => {\n        event.preventDefault();\n    } })), {});\n//# sourceMappingURL=util.js.map"]},"metadata":{},"sourceType":"module"}