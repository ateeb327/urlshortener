{"ast":null,"code":"/**\n * header-row.tsx\n *\n * Forked from reactabular-table version 8.14.0\n * https://github.com/reactabular/reactabular/tree/v8.14.0/packages/reactabular-table/src\n */\nimport * as React from 'react';\nimport { evaluateFormatters } from './evaluate-formatters';\nimport { evaluateTransforms } from './evaluate-transforms';\nimport { mergeProps } from './merge-props';\nimport { HeaderCellInfoWrapper } from '../HeaderCellInfoWrapper';\nexport const HeaderRow = ({\n  rowData,\n  rowIndex,\n  renderers,\n  onRow = () => ({})\n}) => React.createElement(renderers.row, onRow(rowData, {\n  rowIndex\n}), rowData.map((column, columnIndex) => {\n  const {\n    property,\n    header = {},\n    props = {}\n  } = column;\n  const evaluatedProperty = property || header && header.property;\n  const {\n    label,\n    transforms = [],\n    formatters = [],\n    info = {}\n  } = header;\n  const extraParameters = {\n    columnIndex,\n    property: evaluatedProperty,\n    column\n  };\n  const transformedProps = evaluateTransforms(transforms, label, extraParameters);\n  if (!transformedProps) {\n    // tslint:disable-next-line:no-console\n    console.warn('Table.Header - Failed to receive a transformed result'); // eslint-disable-line max-len, no-console\n  }\n  let cellNode;\n  const {\n    tooltip,\n    tooltipProps,\n    popover,\n    popoverProps,\n    ariaLabel,\n    className\n  } = info;\n  // consumer can specify header cell tooltip/popover in two ways, but the transforms approach is preferred,\n  // especially for sorting tables that use `transforms: [sortable]`\n  // {\n  //   title: 'Repositories',\n  //   header: {\n  //     info: {\n  //       tooltip: 'More information about repositories',\n  //       className: 'repositories-info-tip',\n  //       tooltipProps: {\n  //         isContentLeftAligned: true\n  //       }\n  //     }\n  //   }\n  // }\n  //\n  // {\n  //   title: 'Repositories',\n  //   transforms: [\n  //     info({\n  //       tooltip: 'More information about repositories',\n  //       className: 'repositories-info-tip',\n  //       tooltipProps: {\n  //         isContentLeftAligned: true\n  //       }\n  //     }),\n  //     sortable\n  //   ]\n  // },\n  if (tooltip) {\n    cellNode = React.createElement(HeaderCellInfoWrapper, {\n      variant: \"tooltip\",\n      info: tooltip,\n      tooltipProps: tooltipProps,\n      ariaLabel: ariaLabel,\n      className: className\n    }, transformedProps.children || evaluateFormatters(formatters)(label, extraParameters));\n  } else if (popover) {\n    cellNode = React.createElement(HeaderCellInfoWrapper, {\n      variant: \"popover\",\n      info: popover,\n      popoverProps: popoverProps,\n      ariaLabel: ariaLabel,\n      className: className\n    }, transformedProps.children || evaluateFormatters(formatters)(label, extraParameters));\n  } else {\n    cellNode = transformedProps.children || evaluateFormatters(formatters)(label, extraParameters);\n  }\n  return React.createElement(renderers.cell, Object.assign({\n    key: `${columnIndex}-header`\n  }, mergeProps(props, header && header.props, transformedProps)), cellNode);\n}));\nHeaderRow.displayName = 'HeaderRow';","map":{"version":3,"sources":["../../../../../src/components/Table/base/header-row.tsx"],"names":[],"mappings":"AAAA;;;;;AAKG;AACH,OAAO,KAAK,KAAK,MAAM,OAAO;AAC9B,SAAS,kBAAkB,QAAQ,uBAAuB;AAC1D,SAAS,kBAAkB,QAAQ,uBAAuB;AAC1D,SAAS,UAAU,QAAQ,eAAe;AAE1C,SAAS,qBAAqB,QAAQ,0BAA0B;AAShE,OAAO,MAAM,SAAS,GAA4C,CAAC;EACjE,OAAO;EACP,QAAQ;EACR,SAAS;EACT,KAAK,GAAG,CAAA,MAAO,CAAA,CAAE;AAAC,CACH,KACf,KAAK,CAAC,aAAa,CACjB,SAAS,CAAC,GAAwB,EAClC,KAAK,CAAC,OAAO,EAAE;EAAE;AAAQ,CAAE,CAAC,EAC3B,OAAc,CAAC,GAAG,CAAC,CAAC,MAAkB,EAAE,WAAmB,KAAI;EAC9D,MAAM;IAAE,QAAQ;IAAE,MAAM,GAAG,CAAA,CAAgB;IAAE,KAAK,GAAG,CAAA;EAAE,CAAE,GAAG,MAAM;EAClE,MAAM,iBAAiB,GAAG,QAAQ,IAAK,MAAM,IAAI,MAAM,CAAC,QAAS;EACjE,MAAM;IAAE,KAAK;IAAE,UAAU,GAAG,EAAE;IAAE,UAAU,GAAG,EAAE;IAAE,IAAI,GAAG,CAAA;EAAE,CAAE,GAAG,MAAM;EACrE,MAAM,eAAe,GAAG;IACtB,WAAW;IACX,QAAQ,EAAE,iBAAiB;IAC3B;GACD;EACD,MAAM,gBAAgB,GAAG,kBAAkB,CAAC,UAAU,EAAE,KAAK,EAAE,eAAe,CAAC;EAE/E,IAAI,CAAC,gBAAgB,EAAE;IACrB;IACA,OAAO,CAAC,IAAI,CAAC,uDAAuD,CAAC,CAAC,CAAC;EACxE;EAED,IAAI,QAAQ;EACZ,MAAM;IAAE,OAAO;IAAE,YAAY;IAAE,OAAO;IAAE,YAAY;IAAE,SAAS;IAAE;EAAS,CAAE,GAAG,IAAI;EACnF;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA,IAAI,OAAO,EAAE;IACX,QAAQ,GACN,KAAA,CAAA,aAAA,CAAC,qBAAqB,EAAA;MACpB,OAAO,EAAC,SAAS;MACjB,IAAI,EAAE,OAAO;MACb,YAAY,EAAE,YAAY;MAC1B,SAAS,EAAE,SAAS;MACpB,SAAS,EAAE;IAAS,CAAA,EAEnB,gBAAgB,CAAC,QAAQ,IAAI,kBAAkB,CAAC,UAAU,CAAC,CAAC,KAAK,EAAE,eAAe,CAAC,CAEvF;GACF,MAAM,IAAI,OAAO,EAAE;IAClB,QAAQ,GACN,KAAA,CAAA,aAAA,CAAC,qBAAqB,EAAA;MACpB,OAAO,EAAC,SAAS;MACjB,IAAI,EAAE,OAAO;MACb,YAAY,EAAE,YAAY;MAC1B,SAAS,EAAE,SAAS;MACpB,SAAS,EAAE;IAAS,CAAA,EAEnB,gBAAgB,CAAC,QAAQ,IAAI,kBAAkB,CAAC,UAAU,CAAC,CAAC,KAAK,EAAE,eAAe,CAAC,CAEvF;GACF,MAAM;IACL,QAAQ,GAAG,gBAAgB,CAAC,QAAQ,IAAI,kBAAkB,CAAC,UAAU,CAAC,CAAC,KAAK,EAAE,eAAe,CAAC;EAC/F;EAED,OAAO,KAAK,CAAC,aAAa,CACxB,SAAS,CAAC,IAAyB,EAAA,MAAA,CAAA,MAAA,CAAA;IAEjC,GAAG,EAAE,GAAG,WAAW;EAAS,CAAA,EACzB,UAAU,CAAC,KAAK,EAAE,MAAM,IAAI,MAAM,CAAC,KAAK,EAAE,gBAAgB,CAAC,CAAA,EAEhE,QAAQ,CACT;AACH,CAAC,CAAC,CACH;AACH,SAAS,CAAC,WAAW,GAAG,WAAW","sourceRoot":"","sourcesContent":["/**\n * header-row.tsx\n *\n * Forked from reactabular-table version 8.14.0\n * https://github.com/reactabular/reactabular/tree/v8.14.0/packages/reactabular-table/src\n */\nimport * as React from 'react';\nimport { evaluateFormatters } from './evaluate-formatters';\nimport { evaluateTransforms } from './evaluate-transforms';\nimport { mergeProps } from './merge-props';\nimport { HeaderCellInfoWrapper } from '../HeaderCellInfoWrapper';\nexport const HeaderRow = ({ rowData, rowIndex, renderers, onRow = () => ({}) }) => React.createElement(renderers.row, onRow(rowData, { rowIndex }), rowData.map((column, columnIndex) => {\n    const { property, header = {}, props = {} } = column;\n    const evaluatedProperty = property || (header && header.property);\n    const { label, transforms = [], formatters = [], info = {} } = header;\n    const extraParameters = {\n        columnIndex,\n        property: evaluatedProperty,\n        column\n    };\n    const transformedProps = evaluateTransforms(transforms, label, extraParameters);\n    if (!transformedProps) {\n        // tslint:disable-next-line:no-console\n        console.warn('Table.Header - Failed to receive a transformed result'); // eslint-disable-line max-len, no-console\n    }\n    let cellNode;\n    const { tooltip, tooltipProps, popover, popoverProps, ariaLabel, className } = info;\n    // consumer can specify header cell tooltip/popover in two ways, but the transforms approach is preferred,\n    // especially for sorting tables that use `transforms: [sortable]`\n    // {\n    //   title: 'Repositories',\n    //   header: {\n    //     info: {\n    //       tooltip: 'More information about repositories',\n    //       className: 'repositories-info-tip',\n    //       tooltipProps: {\n    //         isContentLeftAligned: true\n    //       }\n    //     }\n    //   }\n    // }\n    //\n    // {\n    //   title: 'Repositories',\n    //   transforms: [\n    //     info({\n    //       tooltip: 'More information about repositories',\n    //       className: 'repositories-info-tip',\n    //       tooltipProps: {\n    //         isContentLeftAligned: true\n    //       }\n    //     }),\n    //     sortable\n    //   ]\n    // },\n    if (tooltip) {\n        cellNode = (React.createElement(HeaderCellInfoWrapper, { variant: \"tooltip\", info: tooltip, tooltipProps: tooltipProps, ariaLabel: ariaLabel, className: className }, transformedProps.children || evaluateFormatters(formatters)(label, extraParameters)));\n    }\n    else if (popover) {\n        cellNode = (React.createElement(HeaderCellInfoWrapper, { variant: \"popover\", info: popover, popoverProps: popoverProps, ariaLabel: ariaLabel, className: className }, transformedProps.children || evaluateFormatters(formatters)(label, extraParameters)));\n    }\n    else {\n        cellNode = transformedProps.children || evaluateFormatters(formatters)(label, extraParameters);\n    }\n    return React.createElement(renderers.cell, Object.assign({ key: `${columnIndex}-header` }, mergeProps(props, header && header.props, transformedProps)), cellNode);\n}));\nHeaderRow.displayName = 'HeaderRow';\n//# sourceMappingURL=header-row.js.map"]},"metadata":{},"sourceType":"module"}