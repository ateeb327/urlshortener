{"ast":null,"code":"import { top, left, right, bottom } from '../enums';\nimport getOffsetParent from '../dom-utils/getOffsetParent';\nimport getWindow from '../dom-utils/getWindow';\nimport getDocumentElement from '../dom-utils/getDocumentElement';\nimport getComputedStyle from '../dom-utils/getComputedStyle';\nimport getBasePlacement from '../utils/getBasePlacement';\nconst unsetSides = {\n  top: 'auto',\n  right: 'auto',\n  bottom: 'auto',\n  left: 'auto'\n};\n// Round the offsets to the nearest suitable subpixel based on the DPR.\n// Zooming can change the DPR, but it seems to report a value that will\n// cleanly divide the values into the appropriate subpixels.\n/**\n *\n */\nfunction roundOffsets({\n  x,\n  y\n}) {\n  const win = window;\n  const dpr = win.devicePixelRatio || 1;\n  return {\n    x: Math.round(x * dpr) / dpr || 0,\n    y: Math.round(y * dpr) / dpr || 0\n  };\n}\n/**\n *\n */\nexport function mapToStyles({\n  popper,\n  popperRect,\n  placement,\n  offsets,\n  position,\n  gpuAcceleration,\n  adaptive\n}) {\n  let {\n    x,\n    y\n  } = roundOffsets(offsets);\n  const hasX = offsets.hasOwnProperty('x');\n  const hasY = offsets.hasOwnProperty('y');\n  let sideX = left;\n  let sideY = top;\n  const win = window;\n  if (adaptive) {\n    let offsetParent = getOffsetParent(popper);\n    if (offsetParent === getWindow(popper)) {\n      offsetParent = getDocumentElement(popper);\n    }\n    // $FlowFixMe: force type refinement, we compare offsetParent with window above, but Flow doesn't detect it\n    /* :: offsetParent = (offsetParent: Element); */\n    if (placement === top) {\n      sideY = bottom;\n      y -= offsetParent.clientHeight - popperRect.height;\n      y *= gpuAcceleration ? 1 : -1;\n    }\n    if (placement === left) {\n      sideX = right;\n      x -= offsetParent.clientWidth - popperRect.width;\n      x *= gpuAcceleration ? 1 : -1;\n    }\n  }\n  const commonStyles = Object.assign({\n    position\n  }, adaptive && unsetSides);\n  if (gpuAcceleration) {\n    return Object.assign(Object.assign({}, commonStyles), {\n      [sideY]: hasY ? '0' : '',\n      [sideX]: hasX ? '0' : '',\n      // Layer acceleration can disable subpixel rendering which causes slightly\n      // blurry text on low PPI displays, so we want to use 2D transforms\n      // instead\n      transform: (win.devicePixelRatio || 1) < 2 ? `translate(${x}px, ${y}px)` : `translate3d(${x}px, ${y}px, 0)`\n    });\n  }\n  return Object.assign(Object.assign({}, commonStyles), {\n    [sideY]: hasY ? `${y}px` : '',\n    [sideX]: hasX ? `${x}px` : '',\n    transform: ''\n  });\n}\n/**\n *\n */\nfunction computeStyles({\n  state,\n  options\n}) {\n  const {\n    gpuAcceleration = true,\n    adaptive = true\n  } = options;\n  if (false /* __DEV__*/) {\n    const transitionProperty = getComputedStyle(state.elements.popper).transitionProperty || '';\n    if (adaptive && ['transform', 'top', 'right', 'bottom', 'left'].some(property => transitionProperty.indexOf(property) >= 0)) {\n      console.warn(['Popper: Detected CSS transitions on at least one of the following', 'CSS properties: \"transform\", \"top\", \"right\", \"bottom\", \"left\".', '\\n\\n', 'Disable the \"computeStyles\" modifier\\'s `adaptive` option to allow', 'for smooth transitions, or remove these properties from the CSS', 'transition declaration on the popper element if only transitioning', 'opacity or background-color for example.', '\\n\\n', 'We recommend using the popper element as a wrapper around an inner', 'element that can have any CSS property transitioned for animations.'].join(' '));\n    }\n  }\n  const commonStyles = {\n    placement: getBasePlacement(state.placement),\n    popper: state.elements.popper,\n    popperRect: state.rects.popper,\n    gpuAcceleration\n  };\n  if (state.modifiersData.popperOffsets != null) {\n    state.styles.popper = Object.assign(Object.assign({}, state.styles.popper), mapToStyles(Object.assign(Object.assign({}, commonStyles), {\n      offsets: state.modifiersData.popperOffsets,\n      position: state.options.strategy,\n      adaptive\n    })));\n  }\n  if (state.modifiersData.arrow != null) {\n    state.styles.arrow = Object.assign(Object.assign({}, state.styles.arrow), mapToStyles(Object.assign(Object.assign({}, commonStyles), {\n      offsets: state.modifiersData.arrow,\n      position: 'absolute',\n      adaptive: false\n    })));\n  }\n  state.attributes.popper = Object.assign(Object.assign({}, state.attributes.popper), {\n    'data-popper-placement': state.placement\n  });\n}\nexport default {\n  name: 'computeStyles',\n  enabled: true,\n  phase: 'beforeWrite',\n  fn: computeStyles,\n  data: {}\n};","map":{"version":3,"sources":["../../../../../../../src/helpers/Popper/thirdparty/popper-core/modifiers/computeStyles.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { top, left, right, bottom } from '../enums';\nimport getOffsetParent from '../dom-utils/getOffsetParent';\nimport getWindow from '../dom-utils/getWindow';\nimport getDocumentElement from '../dom-utils/getDocumentElement';\nimport getComputedStyle from '../dom-utils/getComputedStyle';\nimport getBasePlacement from '../utils/getBasePlacement';\nconst unsetSides = {\n    top: 'auto',\n    right: 'auto',\n    bottom: 'auto',\n    left: 'auto'\n};\n// Round the offsets to the nearest suitable subpixel based on the DPR.\n// Zooming can change the DPR, but it seems to report a value that will\n// cleanly divide the values into the appropriate subpixels.\n/**\n *\n */\nfunction roundOffsets({ x, y }) {\n    const win = window;\n    const dpr = win.devicePixelRatio || 1;\n    return {\n        x: Math.round(x * dpr) / dpr || 0,\n        y: Math.round(y * dpr) / dpr || 0\n    };\n}\n/**\n *\n */\nexport function mapToStyles({ popper, popperRect, placement, offsets, position, gpuAcceleration, adaptive }) {\n    let { x, y } = roundOffsets(offsets);\n    const hasX = offsets.hasOwnProperty('x');\n    const hasY = offsets.hasOwnProperty('y');\n    let sideX = left;\n    let sideY = top;\n    const win = window;\n    if (adaptive) {\n        let offsetParent = getOffsetParent(popper);\n        if (offsetParent === getWindow(popper)) {\n            offsetParent = getDocumentElement(popper);\n        }\n        // $FlowFixMe: force type refinement, we compare offsetParent with window above, but Flow doesn't detect it\n        /* :: offsetParent = (offsetParent: Element); */\n        if (placement === top) {\n            sideY = bottom;\n            y -= offsetParent.clientHeight - popperRect.height;\n            y *= gpuAcceleration ? 1 : -1;\n        }\n        if (placement === left) {\n            sideX = right;\n            x -= offsetParent.clientWidth - popperRect.width;\n            x *= gpuAcceleration ? 1 : -1;\n        }\n    }\n    const commonStyles = Object.assign({ position }, (adaptive && unsetSides));\n    if (gpuAcceleration) {\n        return Object.assign(Object.assign({}, commonStyles), { [sideY]: hasY ? '0' : '', [sideX]: hasX ? '0' : '', \n            // Layer acceleration can disable subpixel rendering which causes slightly\n            // blurry text on low PPI displays, so we want to use 2D transforms\n            // instead\n            transform: (win.devicePixelRatio || 1) < 2 ? `translate(${x}px, ${y}px)` : `translate3d(${x}px, ${y}px, 0)` });\n    }\n    return Object.assign(Object.assign({}, commonStyles), { [sideY]: hasY ? `${y}px` : '', [sideX]: hasX ? `${x}px` : '', transform: '' });\n}\n/**\n *\n */\nfunction computeStyles({ state, options }) {\n    const { gpuAcceleration = true, adaptive = true } = options;\n    if (false /* __DEV__*/) {\n        const transitionProperty = getComputedStyle(state.elements.popper).transitionProperty || '';\n        if (adaptive &&\n            ['transform', 'top', 'right', 'bottom', 'left'].some(property => transitionProperty.indexOf(property) >= 0)) {\n            console.warn([\n                'Popper: Detected CSS transitions on at least one of the following',\n                'CSS properties: \"transform\", \"top\", \"right\", \"bottom\", \"left\".',\n                '\\n\\n',\n                'Disable the \"computeStyles\" modifier\\'s `adaptive` option to allow',\n                'for smooth transitions, or remove these properties from the CSS',\n                'transition declaration on the popper element if only transitioning',\n                'opacity or background-color for example.',\n                '\\n\\n',\n                'We recommend using the popper element as a wrapper around an inner',\n                'element that can have any CSS property transitioned for animations.'\n            ].join(' '));\n        }\n    }\n    const commonStyles = {\n        placement: getBasePlacement(state.placement),\n        popper: state.elements.popper,\n        popperRect: state.rects.popper,\n        gpuAcceleration\n    };\n    if (state.modifiersData.popperOffsets != null) {\n        state.styles.popper = Object.assign(Object.assign({}, state.styles.popper), mapToStyles(Object.assign(Object.assign({}, commonStyles), { offsets: state.modifiersData.popperOffsets, position: state.options.strategy, adaptive })));\n    }\n    if (state.modifiersData.arrow != null) {\n        state.styles.arrow = Object.assign(Object.assign({}, state.styles.arrow), mapToStyles(Object.assign(Object.assign({}, commonStyles), { offsets: state.modifiersData.arrow, position: 'absolute', adaptive: false })));\n    }\n    state.attributes.popper = Object.assign(Object.assign({}, state.attributes.popper), { 'data-popper-placement': state.placement });\n}\nexport default {\n    name: 'computeStyles',\n    enabled: true,\n    phase: 'beforeWrite',\n    fn: computeStyles,\n    data: {}\n};\n//# sourceMappingURL=computeStyles.js.map"]},"metadata":{},"sourceType":"module"}